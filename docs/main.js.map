{"version":3,"file":"main.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/zzfx/ZzFX.js","webpack:///./src/AStar.js","webpack:///./src/Background.js","webpack:///./src/Building.js","webpack:///./src/CPUPlayer.js","webpack:///./src/Camera.js","webpack:///./src/Drawer.js","webpack:///./src/FogOfWar.js","webpack:///./src/HUD.js","webpack:///./src/HumanPlayer.js","webpack:///./src/Keyboard.js","webpack:///./src/Level.js","webpack:///./src/Map.js","webpack:///./src/Mine.js","webpack:///./src/MineCollection.js","webpack:///./src/MiniMap.js","webpack:///./src/Mouse.js","webpack:///./src/Particle.js","webpack:///./src/ParticleCollection.js","webpack:///./src/Player.js","webpack:///./src/Sound.js","webpack:///./src/Sprites.js","webpack:///./src/Unit.js","webpack:///./src/buildingTypes.js","webpack:///./src/collision.js","webpack:///./src/distance.js","webpack:///./src/index.js","webpack:///./src/particleTypes.js","webpack:///./src/unitTypes.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/*\r\n\r\nZzFX - Zuper Zmall Zound Zynth v1.1.8\r\nBy Frank Force 2019\r\nhttps://github.com/KilledByAPixel/ZzFX\r\n\r\nZzFX Features\r\n\r\n- Tiny synth engine with 20 controllable parameters.\r\n- Play sounds via code, no need for sound assed files!\r\n- Compatible with most modern web browsers.\r\n- Small code footprint, the micro version is under 1 kilobyte.\r\n- Can produce a huge variety of sound effect types.\r\n- Sounds can be played with a short call. zzfx(...[,,,,.1,,,,9])\r\n- A small bit of randomness appied to sounds when played.\r\n- Use ZZFX.GetNote to get frequencies on a standard diatonic scale.\r\n- Sounds can be saved out as wav files for offline playback.\r\n- No additional libraries or dependencies are required.\r\n\r\n*/\r\n/*\r\n\r\n  ZzFX MIT License\r\n  \r\n  Copyright (c) 2019 - Frank Force\r\n  \r\n  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n  of this software and associated documentation files (the \"Software\"), to deal\r\n  in the Software without restriction, including without limitation the rights\r\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n  copies of the Software, and to permit persons to whom the Software is\r\n  furnished to do so, subject to the following conditions:\r\n  \r\n  The above copyright notice and this permission notice shall be included in all\r\n  copies or substantial portions of the Software.\r\n  \r\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n  SOFTWARE.\r\n  \r\n*/\r\n\r\n'use strict';\r\n\r\n// play a zzfx sound\r\nexport function zzfx(...parameters) { return ZZFX.play(...parameters) }\r\n\r\n// zzfx object with some extra functionalty\r\nexport const ZZFX =\r\n{\r\n    // master volume scale\r\n    volume: .3,\r\n    \r\n    // sample rate for audio\r\n    sampleRate: 44100,\r\n    \r\n    // create shared audio context\r\n    x: new (window.AudioContext || webkitAudioContext),\r\n\r\n    // play a sound from zzfx paramerters\r\n    play: function(...parameters)\r\n    {\r\n        // build samples and start sound\r\n        return this.playSamples(this.buildSamples(...parameters));\r\n    },\r\n\r\n    // play an array of samples\r\n    playSamples: function(...samples)\r\n    {\r\n        // create buffer and source\r\n        const buffer = this.x.createBuffer(samples.length, samples[0].length, this.sampleRate);\r\n        const source = this.x.createBufferSource();\r\n\r\n        samples.map((d,i)=> buffer.getChannelData(i).set(d));\r\n        source.buffer = buffer;\r\n        source.connect(this.x.destination);\r\n        source.start();\r\n        return source;\r\n    },\r\n\r\n    // build an array of samples\r\n    buildSamples: function\r\n    (\r\n        volume = 1, \r\n        randomness = .05,\r\n        frequency = 220,\r\n        attack = 0,\r\n        sustain = 0,\r\n        release = .1,\r\n        shape = 0,\r\n        shapeCurve = 1,\r\n        slide = 0, \r\n        deltaSlide = 0, \r\n        pitchJump = 0, \r\n        pitchJumpTime = 0, \r\n        repeatTime = 0, \r\n        noise = 0,\r\n        modulation = 0,\r\n        bitCrush = 0,\r\n        delay = 0,\r\n        sustainVolume = 1,\r\n        decay = 0,\r\n        tremolo = 0\r\n    )\r\n    {\r\n        // init parameters\r\n        const PI2 = Math.PI*2;\r\n        let sampleRate = this.sampleRate,\r\n        sign = v => v>0?1:-1,\r\n        startSlide = slide *= 500 * PI2 / sampleRate / sampleRate,\r\n        startFrequency = \r\n            frequency *= (1 + randomness*2*Math.random() - randomness) * PI2 / sampleRate,\r\n        b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, f, length;\r\n\r\n        // scale by sample rate\r\n        attack = attack * sampleRate + 9; // minimum attack to prevent pop\r\n        decay *= sampleRate;\r\n        sustain *= sampleRate;\r\n        release *= sampleRate;\r\n        delay *= sampleRate;\r\n        deltaSlide *= 500 * PI2 / sampleRate**3;\r\n        modulation *= PI2 / sampleRate;\r\n        pitchJump *= PI2 / sampleRate;\r\n        pitchJumpTime *= sampleRate;\r\n        repeatTime = repeatTime * sampleRate | 0;\r\n\r\n        // generate waveform\r\n        for(length = attack + decay + sustain + release + delay | 0;\r\n            i < length; b[i++] = s)\r\n        {\r\n            if (!(++c%(bitCrush*100|0)))                      // bit crush\r\n            { \r\n                s = shape? shape>1? shape>2? shape>3?         // wave shape\r\n                    Math.sin((t%PI2)**3) :                    // 4 noise\r\n                    Math.max(Math.min(Math.tan(t),1),-1):     // 3 tan\r\n                    1-(2*t/PI2%2+2)%2:                        // 2 saw\r\n                    1-4*Math.abs(Math.round(t/PI2)-t/PI2):    // 1 triangle\r\n                    Math.sin(t);                              // 0 sin\r\n\r\n                s = (repeatTime ?\r\n                        1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo\r\n                        : 1) *\r\n                    sign(s)*(Math.abs(s)**shapeCurve) *       // curve 0=square, 2=pointy\r\n                    volume * this.volume * (                  // envelope\r\n                    i < attack ? i/attack :                   // attack\r\n                    i < attack + decay ?                      // decay\r\n                    1-((i-attack)/decay)*(1-sustainVolume) :  // decay falloff\r\n                    i < attack  + decay + sustain ?           // sustain\r\n                    sustainVolume :                           // sustain volume\r\n                    i < length - delay ?                      // release\r\n                    (length - i - delay)/release *            // release falloff\r\n                    sustainVolume :                           // release volume\r\n                    0);                                       // post release\r\n\r\n                s = delay ? s/2 + (delay > i ? 0 :            // delay\r\n                    (i<length-delay? 1 : (length-i)/delay) *  // release delay \r\n                    b[i-delay|0]/2) : s;                      // sample delay\r\n            }\r\n\r\n            f = (frequency += slide += deltaSlide) *          // frequency\r\n                Math.cos(modulation*tm++);                    // modulation\r\n            t += f - f*noise*(1 - (Math.sin(i)+1)*1e9%2);     // noise\r\n\r\n            if (j && ++j > pitchJumpTime)       // pitch jump\r\n            {\r\n                frequency += pitchJump;         // apply pitch jump\r\n                startFrequency += pitchJump;    // also apply to start\r\n                j = 0;                          // stop pitch jump time\r\n            }\r\n\r\n            if (repeatTime && !(++r % repeatTime)) // repeat\r\n            {\r\n                frequency = startFrequency;     // reset frequency\r\n                slide = startSlide;             // reset slide\r\n                j = j || 1;                     // reset pitch jump time\r\n            }\r\n        }\r\n\r\n        return b;\r\n    },\r\n    \r\n    // get frequency of a musical note on a diatonic scale\r\n    getNote: function(semitoneOffset=0, rootNoteFrequency=440)\r\n    {\r\n        return rootNoteFrequency * 2**(semitoneOffset/12);\r\n    }\r\n\r\n} // ZZFX","/* Default comparison function to be used */\nconst defaultCmp = function (x, y) {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  return 0;\n};\n\n/* Push item onto heap, maintaining the heap invariant. */\nconst heappush = function (array, item, cmp) {\n  if (cmp == null) {\n    cmp = defaultCmp;\n  }\n  array.push(item);\n  return _siftdown(array, 0, array.length - 1, cmp);\n};\n\n/* Pop the smallest item off the heap, maintaining the heap invariant. */\nconst heappop = function (array, cmp) {\n  var lastelt, returnitem;\n  if (cmp == null) {\n    cmp = defaultCmp;\n  }\n  lastelt = array.pop();\n  if (array.length) {\n    returnitem = array[0];\n    array[0] = lastelt;\n    _siftup(array, 0, cmp);\n  } else {\n    returnitem = lastelt;\n  }\n  return returnitem;\n};\n\n/*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\nconst updateItem = function (array, item, cmp) {\n  var pos;\n  if (cmp == null) {\n    cmp = defaultCmp;\n  }\n  pos = array.indexOf(item);\n  if (pos === -1) {\n    return;\n  }\n  _siftdown(array, 0, pos, cmp);\n  return _siftup(array, pos, cmp);\n};\n\n/* Find the n smallest elements in a dataset. */\nconst _siftdown = function (array, startpos, pos, cmp) {\n  var newitem, parent, parentpos;\n  if (cmp == null) {\n    cmp = defaultCmp;\n  }\n  newitem = array[pos];\n  while (pos > startpos) {\n    parentpos = (pos - 1) >> 1;\n    parent = array[parentpos];\n    if (cmp(newitem, parent) < 0) {\n      array[pos] = parent;\n      pos = parentpos;\n      continue;\n    }\n    break;\n  }\n  return (array[pos] = newitem);\n};\n\nconst _siftup = function (array, pos, cmp) {\n  var childpos, endpos, newitem, rightpos, startpos;\n  if (cmp == null) {\n    cmp = defaultCmp;\n  }\n  endpos = array.length;\n  startpos = pos;\n  newitem = array[pos];\n  childpos = 2 * pos + 1;\n  while (childpos < endpos) {\n    rightpos = childpos + 1;\n    if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n      childpos = rightpos;\n    }\n    array[pos] = array[childpos];\n    pos = childpos;\n    childpos = 2 * pos + 1;\n  }\n  array[pos] = newitem;\n  return _siftdown(array, startpos, pos, cmp);\n};\n\nconst Heap = (function () {\n  Heap.push = heappush;\n\n  Heap.pop = heappop;\n\n  Heap.updateItem = updateItem;\n\n  function Heap(cmp) {\n    this.cmp = cmp != null ? cmp : defaultCmp;\n    this.nodes = [];\n  }\n\n  Heap.prototype.push = function (x) {\n    return heappush(this.nodes, x, this.cmp);\n  };\n\n  Heap.prototype.pop = function () {\n    return heappop(this.nodes, this.cmp);\n  };\n\n  Heap.prototype.updateItem = function (x) {\n    return updateItem(this.nodes, x, this.cmp);\n  };\n\n  Heap.prototype.empty = function () {\n    return this.nodes.length === 0;\n  };\n\n  return Heap;\n})();\n\n/**\n * Backtrace according to the parent records and return the path.\n * (including both start and end nodes)\n * @param {Node} node End node\n * @return {Array<Array<number>>} the path\n */\nfunction backtrace(node) {\n  var path = [[node.x, node.y]];\n  while (node.parent) {\n    node = node.parent;\n    path.push([node.x, node.y]);\n  }\n  return path.reverse();\n}\n\n/**\n * Given the start and end coordinates, return all the coordinates lying\n * on the line formed by these coordinates, based on Bresenham's algorithm.\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\n * @param {number} x0 Start x coordinate\n * @param {number} y0 Start y coordinate\n * @param {number} x1 End x coordinate\n * @param {number} y1 End y coordinate\n * @return {Array<Array<number>>} The coordinates on the line\n */\nfunction interpolate(x0, y0, x1, y1) {\n  var abs = Math.abs,\n    line = [],\n    sx,\n    sy,\n    dx,\n    dy,\n    err,\n    e2;\n\n  dx = abs(x1 - x0);\n  dy = abs(y1 - y0);\n\n  sx = x0 < x1 ? 1 : -1;\n  sy = y0 < y1 ? 1 : -1;\n\n  err = dx - dy;\n\n  while (true) {\n    line.push([x0, y0]);\n\n    if (x0 === x1 && y0 === y1) {\n      break;\n    }\n\n    e2 = 2 * err;\n    if (e2 > -dy) {\n      err = err - dy;\n      x0 = x0 + sx;\n    }\n    if (e2 < dx) {\n      err = err + dx;\n      y0 = y0 + sy;\n    }\n  }\n\n  return line;\n}\n\n/**\n * Smoothen the give path.\n * The original path will not be modified; a new path will be returned.\n * @param {PF.Grid} grid\n * @param {Array<Array<number>>} path The path\n */\nexport function smoothenPath(grid, path) {\n  var len = path.length,\n    x0 = path[0][0], // path start x\n    y0 = path[0][1], // path start y\n    x1 = path[len - 1][0], // path end x\n    y1 = path[len - 1][1], // path end y\n    sx,\n    sy, // current start coordinate\n    ex,\n    ey, // current end coordinate\n    newPath,\n    i,\n    j,\n    coord,\n    line,\n    testCoord,\n    blocked,\n    lastValidCoord;\n\n  sx = x0;\n  sy = y0;\n  newPath = [[sx, sy]];\n\n  for (i = 2; i < len; ++i) {\n    coord = path[i];\n    ex = coord[0];\n    ey = coord[1];\n    line = interpolate(sx, sy, ex, ey);\n\n    blocked = false;\n    for (j = 1; j < line.length; ++j) {\n      testCoord = line[j];\n\n      if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\n        blocked = true;\n        break;\n      }\n    }\n    if (blocked) {\n      lastValidCoord = path[i - 1];\n      newPath.push(lastValidCoord);\n      sx = lastValidCoord[0];\n      sy = lastValidCoord[1];\n    }\n  }\n  newPath.push([x1, y1]);\n\n  return newPath;\n}\n\n/**\n * @namespace PF.Heuristic\n * @description A collection of heuristic functions.\n */\nvar Heuristic = {\n  manhattan: function (dx, dy) {\n    return dx + dy;\n  },\n};\n\nvar DiagonalMovement = {\n  Never: 2,\n};\n\nfunction Node(x, y, walkable) {\n  /**\n   * The x coordinate of the node on the grid.\n   * @type number\n   */\n  this.x = x;\n  /**\n   * The y coordinate of the node on the grid.\n   * @type number\n   */\n  this.y = y;\n  /**\n   * Whether this node can be walked through.\n   * @type boolean\n   */\n  this.walkable = walkable === undefined ? true : walkable;\n}\n\n/**\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\n * @constructor\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\n * @param {number} height Number of rows of the grid.\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\n *     representing the walkable status of the nodes(0 or false for walkable).\n *     If the matrix is not supplied, all the nodes will be walkable.  */\nexport function Grid(width_or_matrix, height, matrix) {\n  var width;\n\n  if (typeof width_or_matrix !== \"object\") {\n    width = width_or_matrix;\n  } else {\n    height = width_or_matrix.length;\n    width = width_or_matrix[0].length;\n    matrix = width_or_matrix;\n  }\n\n  /**\n   * The number of columns of the grid.\n   * @type number\n   */\n  this.width = width;\n  /**\n   * The number of rows of the grid.\n   * @type number\n   */\n  this.height = height;\n\n  /**\n   * A 2D array of nodes.\n   */\n  this.nodes = this._buildNodes(width, height, matrix);\n}\n\n/**\n * Build and return the nodes.\n * @private\n * @param {number} width\n * @param {number} height\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\n *     the walkable status of the nodes.\n * @see Grid\n */\nGrid.prototype._buildNodes = function (width, height, matrix) {\n  var i,\n    j,\n    nodes = new Array(height);\n\n  for (i = 0; i < height; ++i) {\n    nodes[i] = new Array(width);\n    for (j = 0; j < width; ++j) {\n      nodes[i][j] = new Node(j, i);\n    }\n  }\n\n  if (matrix === undefined) {\n    return nodes;\n  }\n\n  if (matrix.length !== height || matrix[0].length !== width) {\n    throw new Error(\"Matrix size does not fit\");\n  }\n\n  for (i = 0; i < height; ++i) {\n    for (j = 0; j < width; ++j) {\n      if (matrix[i][j]) {\n        // 0, false, null will be walkable\n        // while others will be un-walkable\n        nodes[i][j].walkable = false;\n      }\n    }\n  }\n\n  return nodes;\n};\n\nGrid.prototype.getNodeAt = function (x, y) {\n  return this.nodes[y][x];\n};\n\n/**\n * Determine whether the node at the given position is walkable.\n * (Also returns false if the position is outside the grid.)\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @return {boolean} - The walkability of the node.\n */\nGrid.prototype.isWalkableAt = function (x, y) {\n  return this.isInside(x, y) && this.nodes[y][x].walkable;\n};\n\n/**\n * Determine whether the position is inside the grid.\n * XXX: `grid.isInside(x, y)` is wierd to read.\n * It should be `(x, y) is inside grid`, but I failed to find a better\n * name for this method.\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nGrid.prototype.isInside = function (x, y) {\n  return x >= 0 && x < this.width && y >= 0 && y < this.height;\n};\n\n/**\n * Get the neighbors of the given node.\n *\n *     offsets      diagonalOffsets:\n *  +---+---+---+    +---+---+---+\n *  |   | 0 |   |    | 0 |   | 1 |\n *  +---+---+---+    +---+---+---+\n *  | 3 |   | 1 |    |   |   |   |\n *  +---+---+---+    +---+---+---+\n *  |   | 2 |   |    | 3 |   | 2 |\n *  +---+---+---+    +---+---+---+\n *\n *  When allowDiagonal is true, if offsets[i] is valid, then\n *  diagonalOffsets[i] and\n *  diagonalOffsets[(i + 1) % 4] is valid.\n * @param {Node} node\n * @param {DiagonalMovement} diagonalMovement\n */\nGrid.prototype.getNeighbors = function (node) {\n  var x = node.x,\n    y = node.y,\n    neighbors = [],\n    nodes = this.nodes;\n\n  // ↑\n  if (this.isWalkableAt(x, y - 1)) {\n    neighbors.push(nodes[y - 1][x]);\n  }\n  // →\n  if (this.isWalkableAt(x + 1, y)) {\n    neighbors.push(nodes[y][x + 1]);\n  }\n  // ↓\n  if (this.isWalkableAt(x, y + 1)) {\n    neighbors.push(nodes[y + 1][x]);\n  }\n  // ←\n  if (this.isWalkableAt(x - 1, y)) {\n    neighbors.push(nodes[y][x - 1]);\n  }\n\n  return neighbors;\n};\n\n/**\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\n * @constructor\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\n *     suboptimal paths, in order to speed up the search.\n */\nfunction AStarFinder() {\n  this.heuristic = Heuristic.manhattan;\n  this.weight = 1;\n  this.diagonalMovement = DiagonalMovement.Never;\n}\n\n/**\n * Find and return the the path.\n * @return {Array<Array<number>>} The path, including both start and\n *     end positions.\n */\nAStarFinder.prototype.findPath = function (startX, startY, endX, endY, grid) {\n  var openList = new Heap(function (nodeA, nodeB) {\n      return nodeA.f - nodeB.f;\n    }),\n    startNode = grid.getNodeAt(startX, startY),\n    endNode = grid.getNodeAt(endX, endY),\n    heuristic = this.heuristic,\n    weight = this.weight,\n    abs = Math.abs,\n    SQRT2 = Math.SQRT2,\n    node,\n    neighbors,\n    neighbor,\n    i,\n    l,\n    x,\n    y,\n    ng;\n\n  // set the `g` and `f` value of the start node to be 0\n  startNode.g = 0;\n  startNode.f = 0;\n\n  // push the start node into the open list\n  openList.push(startNode);\n  startNode.opened = true;\n\n  // while the open list is not empty\n  while (!openList.empty()) {\n    // pop the position of node which has the minimum `f` value.\n    node = openList.pop();\n    node.closed = true;\n\n    // if reached the end position, construct the path and return it\n    if (node === endNode) {\n      return backtrace(endNode);\n    }\n\n    // get neigbours of the current node\n    neighbors = grid.getNeighbors(node);\n    for (i = 0, l = neighbors.length; i < l; ++i) {\n      neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      x = neighbor.x;\n      y = neighbor.y;\n\n      // get the distance between current node and the neighbor\n      // and calculate the next g score\n      ng = node.g + (x - node.x === 0 || y - node.y === 0 ? 1 : SQRT2);\n\n      // check if the neighbor has not been inspected yet, or\n      // can be reached with smaller cost from the current node\n      if (!neighbor.opened || ng < neighbor.g) {\n        neighbor.g = ng;\n        neighbor.h =\n          neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n        neighbor.f = neighbor.g + neighbor.h;\n        neighbor.parent = node;\n\n        if (!neighbor.opened) {\n          openList.push(neighbor);\n          neighbor.opened = true;\n        } else {\n          // the neighbor can be reached with smaller cost.\n          // Since its f value has been updated, we have to\n          // update its position in the open list\n          openList.updateItem(neighbor);\n        }\n      }\n    } // end for each neighbor\n  } // end while not open list empty\n\n  // fail to find the path\n  return [];\n};\n\nexport default AStarFinder;\n","export default class Background {\n  constructor({ cw, ch }) {\n    this.stars = Array(500)\n      .fill(0)\n      .map((_) => [\n        Math.random() * cw,\n        Math.random() * ch,\n        Math.floor(Math.random() * 6),\n      ]);\n  }\n\n  draw(drawer) {\n    drawer.draw(() => {\n      drawer.drawBackground(\"#600c0c\", \"#0c6060\");\n    });\n\n    this.stars.forEach(([x, y, o]) => {\n      drawer.rect({\n        adjusted: false,\n        fillColor: \"#fff\" + o,\n        rect: [x, y, 8 - o, 8 - o],\n      });\n    });\n  }\n}\n","import HUD, { ICON_BOX_SIZE, ICON_BOX_MARGIN } from \"./HUD\";\nimport Map from \"./Map\";\nimport Particle from \"./Particle\";\n\nclass Building {\n  constructor(x, y, template, color, built, builder = null, miniMapColor) {\n    this.health = template.health;\n    this.sizeX = template.sizeX;\n    this.sizeY = template.sizeY;\n    this.name = template.name;\n    this.actionsTemplate = template.actions;\n    this.buildingProgress = built ? 0 : template.buildTime;\n    this.cost = template.cost;\n    this.drawBuilding = template.drawBuilding;\n\n    this.x = x;\n    this.y = y;\n    this.lifespan = 0;\n    this.maxHealth = this.health;\n    this.selected = false;\n    this.type = \"building\";\n    this.tasks = [];\n    this.color = color;\n    this.miniMapColor = miniMapColor;\n    this.attackSelected = 0;\n    this.built = built;\n    this.builder = builder;\n    this.bloodColor = \"#666\";\n    this.inFog = 0;\n  }\n\n  attacked() {\n    this.attackSelected = 20;\n  }\n\n  takeDamage(amount, { particles, d }) {\n    this.health -= amount;\n    for (let i = 0; i < amount; i++) {\n      particles.add(\n        new Particle(\n          \"blood\",\n          this.x + this.sizeX / 2,\n          this.y + this.sizeY / 2,\n          Math.random() * 8 - 4 + d.dx * 2,\n          Math.random() * -16 - 8 + d.dy * 2,\n          this.bloodColor\n        )\n      );\n    }\n    return this.health <= 0;\n  }\n\n  explode({ particles, sound }) {\n    sound.play(\"death\");\n    for (let i = 0; i < 100; i++) {\n      particles.add(\n        new Particle(\n          \"blood\",\n          this.x + this.sizeX / 2,\n          this.y + this.sizeY / 2,\n          Math.random() * 8 - 4,\n          Math.random() * -16 - 8,\n          this.bloodColor\n        )\n      );\n    }\n    for (let i = 0; i < 20; i++) {\n      const c = Math.floor(Math.random() * 34 + 51);\n      particles.add(\n        new Particle(\n          \"bit\",\n          this.x + this.sizeX / 2,\n          this.y + this.sizeY / 2,\n          Math.random() * 8 - 4,\n          Math.random() * -16 - 8,\n          `#${c}${c}${c}`\n        )\n      );\n    }\n  }\n\n  hitbox() {\n    return this;\n  }\n\n  tick({ player }) {\n    this.lifespan += 1;\n    const [currentTask] = this.tasks;\n    if (currentTask) {\n      currentTask.time -= 1;\n      if (currentTask.time <= 0) {\n        const { complete } = this.tasks.shift();\n        complete({ player });\n      }\n    }\n\n    if (this.attackSelected > 0) this.attackSelected -= 1;\n  }\n\n  queueTask(task, { player }) {\n    this.tasks.push({ ...task, totalTime: task.time });\n  }\n\n  actions({ player }) {\n    let output = Array(9).fill({});\n\n    const building = this;\n    if (!this.built) {\n      output[8] = {\n        name: \"cancel\",\n        cost: 0,\n        actionable: () => true,\n        execute: ({ player }) => {\n          player.cancelBuilding(this);\n          player.selected = [];\n        },\n        drawIcon: HUD.cancelIcon,\n      };\n    } else {\n      this.actionsTemplate({ building, output, player });\n    }\n    return output;\n  }\n\n  hudDrawCurrentTask(drawer, x, y) {\n    const { name, time, totalTime, drawIcon } = this.tasks[0];\n    drawer.text({\n      text: `${name}`,\n      x: x + 200 + ICON_BOX_SIZE + ICON_BOX_MARGIN,\n      y: y + 13,\n      size: 5,\n    });\n\n    // progress bar\n    const PROGRESS_BAR_WIDTH = 200;\n    const PROGRESS_BAR_HEIGHT = 10;\n    const PROGRESS_BAR_X = x + 200 + ICON_BOX_SIZE + ICON_BOX_MARGIN;\n    const PROGRESS_BAR_Y = y + ICON_BOX_SIZE - PROGRESS_BAR_HEIGHT;\n    drawer.rect({\n      adjusted: false,\n      strokeColor: \"#0f0\",\n      rect: [\n        PROGRESS_BAR_X,\n        PROGRESS_BAR_Y,\n        PROGRESS_BAR_WIDTH,\n        PROGRESS_BAR_HEIGHT,\n      ],\n    });\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#0f0\",\n      rect: [\n        PROGRESS_BAR_X,\n        PROGRESS_BAR_Y,\n        ((totalTime - time) / totalTime) * PROGRESS_BAR_WIDTH,\n        PROGRESS_BAR_HEIGHT,\n      ],\n    });\n    drawer.rect({\n      adjusted: false,\n      strokeColor: \"#0f0\",\n      rect: [x + 200, y, ICON_BOX_SIZE, ICON_BOX_SIZE],\n    });\n    drawIcon(drawer, x + 200, y);\n  }\n\n  hudDraw(drawer, x, y) {\n    if (this.tasks.length) {\n      this.hudDrawCurrentTask(drawer, x, y);\n      this.tasks.slice(1).forEach(({ drawIcon }, i) => {\n        drawer.rect({\n          adjusted: false,\n          strokeColor: \"#0f0\",\n          rect: [\n            x + 200 + (ICON_BOX_MARGIN + ICON_BOX_SIZE) * i,\n            y + ICON_BOX_SIZE + ICON_BOX_MARGIN,\n            ICON_BOX_SIZE,\n            ICON_BOX_SIZE,\n          ],\n        });\n        drawIcon(\n          drawer,\n          x + 200 + (ICON_BOX_MARGIN + ICON_BOX_SIZE) * i,\n          y + ICON_BOX_MARGIN + ICON_BOX_SIZE\n        );\n      });\n    }\n  }\n\n  hudDrawIcon(drawer, x, y) {\n    Building.hudDrawIcon(drawer, x, y);\n  }\n\n  draw(drawer) {\n    const height = this.sizeY - Map.tileSize;\n    const drawRing = (color) => {\n      drawer.ellipse({\n        ellipse: [\n          this.x + this.sizeX / 2,\n          this.y + height + Map.tileSize,\n          (this.sizeX + 40) / 2,\n          height / 3,\n          0,\n          0,\n          2 * Math.PI,\n        ],\n        strokeColor: color,\n        strokeWidth: 5,\n      });\n    };\n    if (this.selected) drawRing(\"#4AC\");\n    if (this.attackSelected > 0) drawRing(\"#A00\");\n\n    this.drawBuilding(\n      drawer,\n      this.x,\n      this.y,\n      this.sizeX,\n      height,\n      this.color,\n      this.built ? \"F\" : \"4\"\n    );\n\n    const hitbox = false;\n    if (hitbox) {\n      drawer.rect({\n        fillColor: \"#A006\",\n        rect: [this.x, this.y, this.sizeX, this.sizeY],\n      });\n    }\n\n    if (!this.inFog) {\n      drawer.miniMap({\n        x: this.x,\n        y: this.y,\n        color: this.miniMapColor,\n        sizeX: Math.ceil(this.sizeX / 20),\n        sizeY: Math.ceil(this.sizeY / 20),\n      });\n    }\n  }\n}\n\nBuilding.hudDrawIcon = (drawer, x, y) => {};\n\nexport default Building;\n","import Player from \"./Player\";\nimport { STATES } from \"./Unit\";\nimport { distance } from \"./distance\";\n\nconst sample = (arr) => arr[Math.floor(Math.random() * arr.length)];\n\nclass CPUPlayer extends Player {\n  constructor({ map }) {\n    super();\n    this.color = \"#00A\";\n    this.miniMapColor = \"#F00\";\n    map.cpuBases.forEach(([x, y]) => {\n      this.addBuilding({ type: \"base\", x: 80 * x, y: 80 * y });\n    });\n    map.cpuShades.forEach(([x, y]) => {\n      this.addUnit({ type: \"shade\", x: 80 * x, y: 80 * y });\n    });\n    map.cpuGoblins.forEach(([x, y]) => {\n      this.addUnit({ type: \"goblin\", x: 80 * x, y: 80 * y });\n    });\n  }\n\n  cpuActions({ map, mines }) {\n    const MOVE_RATE = 0.0;\n    const WORKER_BUILD_RATE = 0.001;\n    const GOBLIN_BUILD_RATE = 0.001;\n\n    // idle workers mine\n    this.units\n      .filter((unit) => unit.name === \"shade\" && unit.state === STATES.IDLE)\n      .forEach((unit) => {\n        mines.mines.sort((a, b) => distance(unit, a) - distance(unit, b));\n        const [mine] = mines.mines;\n        unit.setMining(mine);\n      });\n\n    // idle units randomly wander\n    if (Math.random() < MOVE_RATE) {\n      const unit = sample(this.units.filter((u) => u.state === STATES.IDLE));\n      if (unit) {\n        const path = [\n          Math.floor(80 * 18 + 80 * Math.random() * 5),\n          Math.floor(80 + 80 * Math.random() * 7),\n        ];\n        const success = unit.setPath(path, map);\n        if (success) unit.state = STATES.MOVING;\n        console.log(\n          `cpu moving ${unit.name} to ${path}${success ? \"\" : \", but failed\"}`\n        );\n      }\n    }\n\n    // randomly build workers\n    const [base] = this.buildings.filter((b) => b.name === \"base\");\n    if (Math.random() < WORKER_BUILD_RATE) {\n      this.tryAction(base, \"build shade\");\n    }\n\n    // build one barracks\n    if (\n      this.buildings.filter((b) => b.name === \"barracks\").length === 0 &&\n      this.resources >= 250\n    ) {\n      const builder = sample(this.units.filter((u) => u.builder));\n      if (builder) {\n        this.placeBuildingForConstruction({\n          building: \"barracks\",\n          x: base.x - 300,\n          y: base.y,\n          map,\n          unit: builder,\n        });\n      }\n    }\n\n    // randomly build goblins\n    const [barracks] = this.buildings.filter((b) => b.name === \"barracks\");\n    if (Math.random() < GOBLIN_BUILD_RATE) {\n      this.tryAction(barracks, \"build goblin\");\n    }\n  }\n\n  tryAction(building, actionName) {\n    if (!building || !building.built) return false;\n    const [action] = building\n      .actions({ player: this })\n      .filter(({ name }) => name === actionName);\n\n    try {\n      const success = action.execute({ player: this });\n      console.log(\n        `cpu executing ${action.name} on ${building.name}${\n          success ? \"\" : \", but failed\"\n        }, and has ${this.resources} left`\n      );\n    } catch (e) {\n      console.log(\"cpu errored on action\", building, actionName);\n    }\n  }\n\n  tick({ map, mines, particles, sound, targets }) {\n    this.cpuActions({ map, mines });\n    Player.tick.call(this, { map, particles, sound, targets });\n  }\n\n  draw(drawer) {\n    Player.draw.call(this, drawer);\n  }\n}\n\nexport default CPUPlayer;\n","import HUD from \"./HUD\";\nimport Map from \"./Map\";\n\nclass Camera {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.position_x = 0;\n    this.position_y = 0;\n    this.shakeRemaining = 0;\n    this.shakeForce = 0;\n  }\n\n  setX(x) {\n    this.position_x = this.clampX(x);\n  }\n\n  setY(y) {\n    this.position_y = this.clampY(y);\n  }\n\n  adjustX(x) {\n    return x - this.x;\n  }\n\n  adjustY(y) {\n    return y - this.y;\n  }\n\n  clampX(x) {\n    return Math.min(Math.max(0, x), Map.size - this.width);\n  }\n\n  clampY(y) {\n    return Math.min(\n      Math.max(0, y),\n      Map.size * (Map.tileSizeY / Map.tileSize) - this.height\n    );\n  }\n\n  shake(force, duration) {\n    if (force >= this.shakeForce || this.shakeRemaining === 0) {\n      this.shakeRemaining = duration;\n      this.shakeForce = force;\n    }\n  }\n\n  applyShake() {\n    this.shakeRemaining = Math.max(0, this.shakeRemaining - 1);\n    if (!this.shakeRemaining) return;\n    const shakeX = Math.random() * this.shakeForce * 2 - this.shakeForce;\n    const shakeY = Math.random() * this.shakeForce * 2 - this.shakeForce;\n    this.x += shakeX;\n    this.y += shakeY;\n  }\n\n  tick({ keyboard, mouse }) {\n    const SPEED = 15;\n    const THRESHOLD = HUD.HUD_PADDING;\n    const [mx, my] = mouse.mouseScreenLocation;\n\n    if (keyboard.isDown(keyboard.UP) || my < THRESHOLD)\n      this.position_y -= SPEED;\n    if (keyboard.isDown(keyboard.DOWN) || my > this.height - THRESHOLD)\n      this.position_y += SPEED;\n    if (keyboard.isDown(keyboard.LEFT) || mx < THRESHOLD)\n      this.position_x -= SPEED;\n    if (keyboard.isDown(keyboard.RIGHT) || mx > this.width - THRESHOLD)\n      this.position_x += SPEED;\n\n    this.setX(this.position_x);\n    this.setY(this.position_y);\n\n    this.x = this.position_x;\n    this.y = this.position_y;\n\n    this.applyShake();\n  }\n}\n\nexport default Camera;\n","import Camera from \"./Camera\";\nimport HUD from \"./HUD\";\nimport Map from \"./Map\";\n\nlet cx = null;\n\nexport default class Drawer {\n  constructor() {\n    let canvas = document.querySelector(\"canvas\");\n    this.canvas = canvas;\n    cx = this.canvas.getContext(\"2d\");\n    this.camera = new Camera();\n\n    let container = document.querySelector(\"body\");\n    let resize = () => {\n      this.camera.height = window.innerHeight;\n      this.camera.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      canvas.width = window.innerWidth;\n      this.height = canvas.height;\n      this.width = canvas.width;\n    };\n    resize();\n    container.onresize = resize;\n\n    this.miniMapObjects = [];\n  }\n\n  draw(d) {\n    cx.save();\n    d();\n    cx.restore();\n  }\n\n  clearBackground() {\n    cx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  drawBackground(start, end) {\n    this.draw(() => {\n      const gradient = cx.createLinearGradient(\n        0,\n        0,\n        this.height - HUD.HUD_HEIGHT,\n        this.width\n      );\n\n      gradient.addColorStop(0, start);\n      gradient.addColorStop(1, end);\n\n      cx.fillStyle = gradient;\n\n      cx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    });\n  }\n\n  rect({\n    rect,\n    fillColor,\n    strokeColor,\n    shadowBlur = 0,\n    shadowColor = \"none\",\n    opacity,\n    lineWidth = 1,\n    adjusted = true,\n    rotation,\n    size,\n    crisp = true,\n  }) {\n    if (crisp) {\n      rect[0] = Math.floor(rect[0]);\n      rect[1] = Math.floor(rect[1]);\n    }\n    if (adjusted) {\n      rect[0] = this.camera.adjustX(rect[0], this.canvas.width);\n      rect[1] = this.camera.adjustY(rect[1], this.canvas.height);\n    }\n    if (rotation) {\n      cx.translate(rect[0] + size / 2, rect[1] + size / 2);\n      cx.rotate(rotation);\n      cx.translate(-1 * rect[0] - size / 2, -1 * rect[1] - size / 2);\n    }\n    cx.shadowBlur = shadowBlur;\n    cx.shadowColor = shadowColor;\n    if (opacity) {\n      cx.globalAlpha = opacity;\n    }\n    if (fillColor) {\n      cx.fillStyle = fillColor;\n      cx.fillRect(...[rect[0], rect[1], ...rect.slice(2)]);\n    }\n    if (strokeColor) {\n      cx.strokeStyle = strokeColor;\n      cx.lineWidth = lineWidth;\n      cx.strokeRect(...[rect[0], rect[1], ...rect.slice(2)]);\n    }\n    cx.shadowBlur = 0;\n    cx.globalAlpha = 1;\n  }\n\n  triangle({ x, y, adjusted = true, fillColor, rotation, size }) {\n    this.draw(() => {\n      if (adjusted) {\n        x = this.camera.adjustX(x, this.canvas.width);\n        y = this.camera.adjustY(y, this.canvas.height);\n      }\n      if (rotation) {\n        cx.translate(x + size / 2, y + size / 2);\n        cx.rotate(rotation);\n        cx.translate(-1 * x - size / 2, -1 * y - size / 2);\n      }\n      if (fillColor) {\n        let region = new Path2D();\n        region.moveTo(x, y);\n        region.lineTo(x + size, y);\n        region.lineTo(x, y + size);\n        region.closePath();\n\n        cx.fillStyle = fillColor;\n        cx.fill(region);\n      }\n    });\n  }\n\n  ellipse({\n    ellipse,\n    adjusted = true,\n    fillColor,\n    strokeColor,\n    strokeWidth = 1,\n    shadowBlur,\n    shadowColor,\n  }) {\n    if (adjusted) {\n      ellipse[0] = this.camera.adjustX(ellipse[0], this.canvas.width);\n      ellipse[1] = this.camera.adjustY(ellipse[1], this.canvas.height);\n    }\n    cx.beginPath();\n    cx.ellipse(...ellipse);\n    cx.shadowBlur = shadowBlur;\n    cx.shadowColor = shadowColor;\n    if (fillColor) {\n      cx.fillStyle = fillColor;\n      cx.fill();\n    }\n    if (strokeColor) {\n      cx.strokeStyle = strokeColor;\n      cx.lineWidth = strokeWidth;\n      cx.stroke();\n    }\n    cx.shadowBlur = 0;\n  }\n\n  text({ text, x, y, fillColor = \"#fff\", size = 1 }) {\n    cx.fillStyle = fillColor;\n\n    let currX = 0;\n\n    text\n      .toUpperCase()\n      .split(\"\")\n      .map((c) => {\n        if (!letters[c]) console.log(c);\n        return letters[c];\n      })\n      .forEach((letter) => {\n        let currY = 0;\n        let addX = 0;\n        letter.forEach((row) => {\n          row.forEach((bit, i) => {\n            bit && cx.fillRect(currX + i * size + x, currY + y, size, size);\n          });\n          addX = Math.max(addX, row.length * size);\n          currY += size;\n        });\n        currX += size + addX;\n      });\n  }\n\n  lines({\n    lines,\n    shadowBlur = 0,\n    shadowColor,\n    fillColor,\n    strokeColor,\n    adjusted = true,\n  }) {\n    cx.beginPath();\n    let sx = lines[0][0];\n    let sy = lines[0][1];\n    if (adjusted) {\n      sx = this.camera.adjustX(sx, this.canvas.width);\n      sy = this.camera.adjustY(sy, this.canvas.height);\n    }\n    cx.moveTo(sx, sy);\n    lines.slice(1).forEach(([x, y]) => {\n      if (adjusted) {\n        x = this.camera.adjustX(x, this.canvas.width);\n        y = this.camera.adjustY(y, this.canvas.height);\n      }\n      cx.lineTo(x, y);\n    });\n    cx.closePath();\n    cx.shadowBlur = shadowBlur;\n    cx.shadowColor = shadowColor;\n    if (strokeColor) {\n      cx.strokeStyle = strokeColor;\n      cx.stroke();\n    }\n    if (fillColor) {\n      cx.fillStyle = fillColor;\n      cx.fill();\n    }\n  }\n\n  emoji({ emoji, x, y, flipped, adjusted = true }) {\n    this.draw(() => {\n      if (adjusted) {\n        x = this.camera.adjustX(x, this.canvas.width);\n        y = this.camera.adjustY(y, this.canvas.height);\n      }\n      if (flipped) {\n        // cx.scale(-1, 1);\n        // cx.translate(canvasWidth.width / 2, canvasHeight.height / 2);\n      }\n\n      cx.font = \"6px serif\";\n      cx.fillText(emoji, x, y + 2);\n    });\n  }\n\n  miniMap({ x, y, size, sizeX, sizeY, color }) {\n    const miniMapSize = 250;\n    this.miniMapObjects.push(() =>\n      this.rect({\n        adjusted: false,\n        fillColor: color,\n        rect: [\n          (x / Map.size) * miniMapSize + HUD.HUD_PADDING,\n          this.canvas.height -\n            miniMapSize +\n            (y / Map.size) * miniMapSize -\n            HUD.HUD_PADDING,\n          sizeX || size,\n          sizeY || size,\n        ],\n      })\n    );\n  }\n\n  clearMiniMap() {\n    this.miniMapObjects = [];\n  }\n\n  renderMiniMap() {\n    this.miniMapObjects.forEach((obj) => {\n      this.draw(obj);\n    });\n  }\n\n  hitbox({ x, y, size }) {\n    this.rect({\n      rect: [x - size / 2, y - size / 2, size, size],\n      color: \"#f00\",\n    });\n  }\n}\n\nconst letters = {};\nletters[\"A\"] = [\n  [, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n  [1, , 1],\n];\nletters[\"B\"] = [\n  [1, 1],\n  [1, , 1],\n  [1, 1, 1],\n  [1, , 1],\n  [1, 1],\n];\nletters[\"C\"] = [[1, 1, 1], [1], [1], [1], [1, 1, 1]];\nletters[\"D\"] = [\n  [1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1],\n];\nletters[\"E\"] = [[1, 1, 1], [1], [1, 1, 1], [1], [1, 1, 1]];\nletters[\"F\"] = [[1, 1, 1], [1], [1, 1], [1], [1]];\nletters[\"G\"] = [[, 1, 1], [1], [1, , 1, 1], [1, , , 1], [, 1, 1]];\nletters[\"H\"] = [\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n  [1, , 1],\n  [1, , 1],\n];\nletters[\"I\"] = [\n  [1, 1, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n  [1, 1, 1],\n];\nletters[\"J\"] = [\n  [1, 1, 1],\n  [, , 1],\n  [, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"K\"] = [\n  [1, , , 1],\n  [1, , 1],\n  [1, 1],\n  [1, , 1],\n  [1, , , 1],\n];\nletters[\"L\"] = [[1], [1], [1], [1], [1, 1, 1]];\nletters[\"M\"] = [\n  [1, 1, 1, 1, 1],\n  [1, , 1, , 1],\n  [1, , 1, , 1],\n  [1, , , , 1],\n  [1, , , , 1],\n];\nletters[\"N\"] = [\n  [1, , , 1],\n  [1, 1, , 1],\n  [1, , 1, 1],\n  [1, , , 1],\n  [1, , , 1],\n];\nletters[\"O\"] = [\n  [1, 1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"P\"] = [[1, 1, 1], [1, , 1], [1, 1, 1], [1], [1]];\nletters[\"Q\"] = [\n  [0, 1, 1],\n  [1, , , 1],\n  [1, , , 1],\n  [1, , 1, 1],\n  [1, 1, 1, 1],\n];\nletters[\"R\"] = [\n  [1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1],\n  [1, , 1],\n];\nletters[\"S\"] = [[1, 1, 1], [1], [1, 1, 1], [, , 1], [1, 1, 1]];\nletters[\"T\"] = [\n  [1, 1, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n];\nletters[\"U\"] = [\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"V\"] = [\n  [1, , , , 1],\n  [1, , , , 1],\n  [, 1, , 1],\n  [, 1, , 1],\n  [, , 1],\n];\nletters[\"W\"] = [\n  [1, , , , 1],\n  [1, , , , 1],\n  [1, , , , 1],\n  [1, , 1, , 1],\n  [1, 1, 1, 1, 1],\n];\nletters[\"X\"] = [\n  [1, , , , 1],\n  [, 1, , 1],\n  [, , 1],\n  [, 1, , 1],\n  [1, , , , 1],\n];\nletters[\"Y\"] = [\n  [1, , 1],\n  [1, , 1],\n  [, 1],\n  [, 1],\n  [, 1],\n];\nletters[\"Z\"] = [\n  [1, 1, 1, 1, 1],\n  [, , , 1],\n  [, , 1],\n  [, 1],\n  [1, 1, 1, 1, 1],\n];\nletters[\" \"] = [\n  [, ,],\n  [, ,],\n  [, ,],\n  [, ,],\n  [, ,],\n];\nletters[\"0\"] = [\n  [1, 1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"1\"] = [\n  [, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n];\nletters[\"2\"] = [\n  [1, 1, 1],\n  [, , 1],\n  [1, 1, 1],\n  [1, ,],\n  [1, 1, 1],\n];\nletters[\"3\"] = [\n  [1, 1, 1],\n  [, , 1],\n  [1, 1, 1],\n  [, , 1],\n  [1, 1, 1],\n];\nletters[\"4\"] = [\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n  [, , 1],\n  [, , 1],\n];\nletters[\"5\"] = [\n  [1, 1, 1],\n  [1, ,],\n  [1, 1, 1],\n  [, , 1],\n  [1, 1, 1],\n];\nletters[\"6\"] = [\n  [1, 1, 1],\n  [1, ,],\n  [1, 1, 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"7\"] = [\n  [1, 1, 1],\n  [, , 1],\n  [, , 1],\n  [, , 1],\n  [, , 1],\n];\nletters[\"8\"] = [\n  [1, 1, 1],\n  [1, , 1],\n  [1, 1, 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"9\"] = [\n  [1, 1, 1],\n  [1, , 1],\n  [1, 1, 1],\n  [, , 1],\n  [1, 1, 1],\n];\nletters[\"/\"] = [\n  [, , 1],\n  [, , 1],\n  [, 1],\n  [1, ,],\n  [1, ,],\n];\nletters[\"!\"] = [\n  [, 1],\n  [, 1],\n  [, 1],\n  [, ,],\n  [, 1],\n];\n","import Map from \"./Map\";\n\nclass FogOfWar {\n  constructor() {\n    this.tiles = [];\n  }\n\n  tick({ humanPlayer, cpuPlayer, mines, map }) {\n    const tiles = [];\n    for (let y = 0; y < map.height; y++) {\n      const row = [];\n      for (let x = 0; x < map.width; x++) {\n        row.push(1);\n      }\n      tiles.push(row);\n    }\n\n    const clampX = (x) => Math.min(Math.max(0, x), map.width - 1);\n    const clampY = (y) => Math.min(Math.max(0, y), map.height - 1);\n\n    humanPlayer.entities().forEach((e) => {\n      const SIGHT = 10;\n\n      const [x, y] = map.coordsToTile(e.x, e.y);\n\n      for (let dy = clampY(y - SIGHT); dy <= clampY(y + SIGHT); dy++) {\n        const d = Math.floor(\n          Math.sqrt(Math.abs(SIGHT ** 2 - Math.abs(dy - y) ** 2))\n        );\n        for (let dx = clampX(x - d); dx <= clampX(x + d); dx++) {\n          tiles[dy][dx] = 0;\n        }\n      }\n    });\n\n    cpuPlayer\n      .entities()\n      .concat(mines.mines)\n      .forEach((e) => {\n        const { x, y } = e;\n        e.inFog =\n          tiles[Math.floor(y / Map.tileSize)][Math.floor(x / Map.tileSize)];\n      });\n\n    this.tiles = tiles;\n  }\n\n  draw(drawer) {\n    // return;\n    this.tiles.forEach((row, y) => {\n      row.forEach((tile, x) => {\n        if (!tile) return;\n        drawer.rect({\n          fillColor: \"#222\",\n          rect: [\n            x * Map.tileSizeX,\n            y * Map.tileSizeY,\n            Map.tileSizeX,\n            Map.tileSizeY,\n          ],\n        });\n      });\n    });\n  }\n}\n\nexport default FogOfWar;\n","import Map from \"./Map\";\n\nexport const ICON_BOX_SIZE = 60;\nexport const ICON_BOX_MARGIN = 10;\n\nconst INFOBOX_ICON_ROW_MAX = 8;\n\nconst INFOBOX_PADDING = 20;\n\nconst ACTIONBOX_ROW_MAX = 3;\n\nconst miniMapSize = 250;\n\nclass HUD {\n  constructor() {\n    this.selected = [];\n  }\n\n  tick({ camera, drawer, map, mouse, player, sound }) {\n    this.selected = player.selected;\n    this.resources = player.resources;\n    this.drawerWidth = drawer.width;\n    this.drawerHeight = drawer.height;\n    this.actionboxX = this.drawerWidth - HUD.HUD_HEIGHT - HUD.HUD_PADDING;\n    this.actionboxY = this.drawerHeight - HUD.HUD_HEIGHT - HUD.HUD_PADDING;\n    this.infoboxX = miniMapSize + HUD.HUD_PADDING * 2;\n    this.infoboxY = drawer.height - HUD.HUD_HEIGHT - HUD.HUD_PADDING;\n    this.actionBoxes = this.getActionBoxes({ player });\n    this.actionBoxText = \"\";\n\n    if (this.selected.length) {\n      if (mouse.clickTarget[0] || mouse.clickTarget[1]) {\n        this.clickAction({ camera, mouse, player });\n      }\n      if (mouse.mouseLocation[0] || mouse.mouseLocation[1]) {\n        this.hoverActions({ camera, mouse });\n      }\n    }\n\n    this.miniMapClick({ camera, drawer, map, mouse, player });\n    this.miniMapRightClick({ camera, drawer, map, mouse, player, sound });\n  }\n\n  miniMapClick({ camera, drawer, map, mouse, player }) {\n    const miniMapSize = 250;\n    const { clicked, x, y } = player.inMiniMap(\n      mouse.clickTarget,\n      mouse.clicked,\n      drawer,\n      camera\n    );\n    if (clicked) {\n      const width = (drawer.width / Map.size) * miniMapSize;\n      const height =\n        (drawer.height / ((Map.tileSizeY / Map.tileSize) * Map.size)) *\n        miniMapSize;\n      const cameraX = ((x - width / 2) / miniMapSize) * 80 * map.width;\n      const cameraY = ((y - height / 2) / miniMapSize) * 80 * map.height;\n      camera.setX(cameraX);\n      camera.setY(cameraY);\n    }\n  }\n\n  miniMapRightClick({ camera, drawer, map, mouse, player, sound }) {\n    const miniMapSize = 250;\n    const { clicked, x, y } = player.inMiniMap(\n      mouse.rightClickTarget,\n      mouse.rightClicked,\n      drawer,\n      camera\n    );\n    if (clicked) {\n      const mapX = (x / miniMapSize) * 80 * map.width;\n      const mapY = (y / miniMapSize) * 80 * map.height;\n      if (player.selected.length > 0) {\n        player.moveGroup(player.selected, map, [mapX, mapY], sound);\n      }\n    }\n  }\n\n  clickAction({ camera, mouse, player }) {\n    let [mouseX, mouseY] = mouse.clickTarget;\n    this.actionBoxes.forEach(({ x, y, width, height, action }) => {\n      if (!action.name) return;\n      if (\n        mouseX - camera.x >= x &&\n        mouseX - camera.x < x + width &&\n        mouseY - camera.y >= y &&\n        mouseY - camera.y < y + height\n      ) {\n        if (action.actionable()) {\n          action.execute({ player });\n        }\n      }\n    });\n  }\n\n  hoverActions({ camera, mouse }) {\n    let [mouseX, mouseY] = mouse.mouseLocation;\n    this.actionBoxes.forEach(({ x, y, width, height, action }) => {\n      if (\n        mouseX - camera.x >= x &&\n        mouseX - camera.x < x + width &&\n        mouseY - camera.y >= y &&\n        mouseY - camera.y < y + height\n      ) {\n        this.actionBoxText = action.name;\n      }\n    });\n  }\n\n  getActionBoxes({ player }) {\n    if (this.selected.length === 0) return [];\n    const [entity] = this.selected;\n    return entity.actions({ player }).map((action, i) => {\n      const x =\n        this.actionboxX +\n        INFOBOX_PADDING +\n        ICON_BOX_SIZE * (i % ACTIONBOX_ROW_MAX) +\n        ICON_BOX_MARGIN * ((i % ACTIONBOX_ROW_MAX) - 1);\n      const y =\n        this.infoboxY +\n        INFOBOX_PADDING +\n        ICON_BOX_SIZE * Math.floor(i / ACTIONBOX_ROW_MAX) +\n        ICON_BOX_MARGIN * (Math.floor(i / ACTIONBOX_ROW_MAX) - 1);\n      return {\n        x,\n        y,\n        width: ICON_BOX_SIZE,\n        height: ICON_BOX_SIZE,\n        icon: action.drawIcon,\n        action,\n      };\n    });\n  }\n\n  draw(drawer) {\n    // resources\n    const RESOURCES_X = drawer.width - 140;\n    const RESOURCES_Y = 15;\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#69c\",\n      rect: [RESOURCES_X, RESOURCES_Y + 2, 20, 20],\n    });\n    drawer.text({\n      text: `${this.resources}`,\n      x: RESOURCES_X + 30,\n      y: RESOURCES_Y,\n      size: 5,\n    });\n\n    // hud background\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#666\",\n      rect: [\n        0,\n        drawer.height - HUD.HUD_HEIGHT - HUD.HUD_PADDING * 2,\n        drawer.width,\n        HUD.HUD_HEIGHT + HUD.HUD_PADDING * 2,\n      ],\n    });\n\n    // infobox\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#111\",\n      rect: [\n        this.infoboxX,\n        this.infoboxY,\n        drawer.width - HUD.HUD_HEIGHT - miniMapSize - HUD.HUD_PADDING * 4,\n        HUD.HUD_HEIGHT,\n      ],\n    });\n\n    if (this.selected.length === 1) {\n      // one selected\n      const [entity] = this.selected;\n      drawer.text({\n        text: entity.name,\n        x: this.infoboxX + INFOBOX_PADDING,\n        y: this.infoboxY + INFOBOX_PADDING,\n        size: 5,\n      });\n\n      entity.hudDraw(\n        drawer,\n        this.infoboxX + INFOBOX_PADDING,\n        this.infoboxY + INFOBOX_PADDING + 60,\n        entity.name\n      );\n\n      drawer.text({\n        text: `${entity.health} / ${entity.maxHealth}`,\n        x: this.infoboxX + INFOBOX_PADDING,\n        y: this.infoboxY + INFOBOX_PADDING + 140,\n        size: 3,\n      });\n    } else if (this.selected.length > 1) {\n      // multiple selected\n      const units = this.selected.slice(0, INFOBOX_ICON_ROW_MAX * 3);\n      units.forEach((unit, i) => {\n        const x =\n          this.infoboxX +\n          INFOBOX_PADDING +\n          ICON_BOX_SIZE * (i % INFOBOX_ICON_ROW_MAX) +\n          ICON_BOX_MARGIN * ((i % INFOBOX_ICON_ROW_MAX) - 1);\n        const y =\n          this.infoboxY +\n          INFOBOX_PADDING +\n          ICON_BOX_SIZE * Math.floor(i / INFOBOX_ICON_ROW_MAX) +\n          ICON_BOX_MARGIN * (Math.floor(i / INFOBOX_ICON_ROW_MAX) - 1);\n        drawer.rect({\n          adjusted: false,\n          strokeColor: \"#0f0\",\n          rect: [x, y, ICON_BOX_SIZE, ICON_BOX_SIZE],\n        });\n        drawer.rect({\n          adjusted: false,\n          strokeColor: \"#0f0\",\n          rect: [x, y, ICON_BOX_SIZE, ICON_BOX_SIZE],\n        });\n        unit.hudDrawIcon(drawer, x, y, unit.name);\n      });\n    }\n\n    // actions\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#111\",\n      rect: [this.actionboxX, this.actionboxY, HUD.HUD_HEIGHT, HUD.HUD_HEIGHT],\n    });\n    if (this.selected.length === 1) {\n      this.actionBoxes.forEach(({ x, y, width, height, icon, action }) => {\n        if (!action.name) return;\n        drawer.rect({\n          adjusted: false,\n          strokeColor: action.actionable()\n            ? \"#0f0\"\n            : \"rgba(100, 100, 100, 0.7)\",\n          rect: [x, y, width, height],\n        });\n        icon(drawer, x, y);\n        if (!action.actionable()) {\n          drawer.rect({\n            adjusted: false,\n            fillColor: \"rgba(100, 100, 100, 0.7)\",\n            rect: [x, y, width, height],\n          });\n        }\n      });\n    }\n\n    if (this.actionBoxText) {\n      drawer.text({\n        text: this.actionBoxText,\n        x: this.actionboxX + ICON_BOX_MARGIN,\n        y: this.actionboxY + (ICON_BOX_SIZE + ICON_BOX_MARGIN) * 3 - 17,\n        size: 3,\n      });\n    }\n  }\n}\n\nHUD.cancelIcon = (drawer, x, y) => {\n  drawer.ellipse({\n    adjusted: false,\n    ellipse: [\n      x + ICON_BOX_SIZE / 2,\n      y + ICON_BOX_SIZE / 2,\n      20,\n      20,\n      0,\n      0,\n      2 * Math.PI,\n    ],\n    strokeColor: \"#0F0\",\n    strokeWidth: 6,\n  });\n  drawer.draw(() => {\n    drawer.rect({\n      adjusted: false,\n      rect: [x + ICON_BOX_SIZE / 4, y + ICON_BOX_SIZE / 4, 40, 6],\n      fillColor: \"#0F0\",\n      rotation: Math.PI / 4,\n      size: 6,\n    });\n  });\n};\n\nHUD.HUD_HEIGHT = 220;\nHUD.HUD_PADDING = 10;\n\nexport default HUD;\n","import Building from \"./Building\";\nimport HUD from \"./HUD\";\nimport Map from \"./Map\";\nimport Player from \"./Player\";\nimport { STATES } from \"./Unit\";\nimport buildingTypes from \"./buildingTypes\";\nimport { boxCollision, pointCollision } from \"./collision\";\n\nconst MODES = { NORMAL: 0, PLACE_BUILDING: 1 };\n\nclass HumanPlayer extends Player {\n  constructor({ map }) {\n    super();\n    this.selected = [];\n    this.color = \"#A00\";\n    this.miniMapColor = \"#0F0\";\n    map.humanBases.forEach(([x, y]) => {\n      this.addBuilding({ type: \"base\", x: 80 * x, y: 80 * y });\n    });\n    map.humanShades.forEach(([x, y]) => {\n      this.addUnit({ type: \"shade\", x: 80 * x, y: 80 * y });\n    });\n    map.humanGoblins.forEach(([x, y]) => {\n      this.addUnit({ type: \"goblin\", x: 80 * x, y: 80 * y });\n    });\n    this.mode = MODES.NORMAL;\n    this.placeBuildingUnit = null;\n    this.placeBuildingBuilding = null;\n    this.drawPlaceBuilding = null;\n    this.moveFeedback = [];\n  }\n\n  dragSelect(mouse, entities, sound) {\n    let collisions = entities.filter((entity) => {\n      let [mx, my, endx, endy] = mouse.releaseDrag;\n      return boxCollision(entity.hitbox(), {\n        x: mx,\n        y: my,\n        sizeX: endx - mx,\n        sizeY: endy - my,\n      });\n    });\n    if (collisions.map((c) => c.type).includes(\"unit\")) {\n      collisions = collisions.filter((c) => c.type === \"unit\");\n    }\n    if (collisions.length === 0) return;\n    sound.play(\"click\");\n    entities.forEach((entity) => (entity.selected = false));\n    collisions.forEach((entity) => (entity.selected = true));\n    this.selected = collisions;\n  }\n\n  clickSelect(mouse, entities, sound) {\n    let [mouseX, mouseY] = mouse.clickTarget;\n    if (mouseX || mouseY) {\n      entities.forEach((entity) => {\n        if (pointCollision(entity.hitbox(), { x: mouseX, y: mouseY })) {\n          entities.forEach((entity) => (entity.selected = false));\n          this.selected = [entity];\n          entity.selected = true;\n          sound.play(\"click\");\n        }\n      });\n    }\n  }\n\n  select(mouse, sound) {\n    const entities = [this.units, this.buildings].flat();\n    if (mouse.releaseDrag) {\n      this.dragSelect(mouse, entities, sound);\n    } else {\n      this.clickSelect(mouse, entities, sound);\n    }\n  }\n\n  enemyEntities({ cpuPlayer, target }) {\n    const { buildings, units } = cpuPlayer;\n    const enemies = units.concat(buildings);\n    return enemies.filter((enemy) =>\n      pointCollision(enemy.hitbox(), { x: target[0], y: target[1] })\n    );\n  }\n\n  unitActions({ cpuPlayer, map, mines, mouse, sound, unit }) {\n    const { rightClickTarget } = mouse;\n\n    if (unit.state === STATES.BUILD_BUILDING) return;\n    if (mouse.rightClickTarget[0] || mouse.rightClickTarget[1]) {\n      if (unit.canMine) {\n        const [mine] = mines.mines.filter((mine) =>\n          pointCollision(mine, {\n            x: rightClickTarget[0],\n            y: rightClickTarget[1],\n          })\n        );\n        if (mine) {\n          unit.setMining(mine);\n          sound.play(\"click\");\n          return;\n        }\n        if (unit.carryingResource) {\n          const [base] = this.buildings.filter(\n            (building) =>\n              building.name === \"base\" &&\n              pointCollision(building.hitbox(), {\n                x: rightClickTarget[0],\n                y: rightClickTarget[1],\n              })\n          );\n          if (base) {\n            unit.returnResource(this, map, base);\n            sound.play(\"click\");\n            return;\n          }\n        }\n      }\n\n      const [enemy] = this.enemyEntities({\n        cpuPlayer,\n        target: rightClickTarget,\n      });\n      if (enemy) {\n        unit.setTarget(enemy, map);\n        sound.play(\"click\");\n        return;\n      }\n\n      return true;\n    }\n  }\n\n  placeBuildingMode({ unit, building }) {\n    this.mode = MODES.PLACE_BUILDING;\n    this.placeBuildingUnit = unit;\n    this.placeBuildingBuilding = building;\n  }\n\n  cancelPlaceBuilding() {\n    this.mode = MODES.INITIAL;\n    this.placeBuildingUnit = null;\n    this.placeBuildingBuilding = null;\n  }\n\n  placeBuildingActions(map, mouse, sound) {\n    const { clickTarget, mouseLocation } = mouse;\n    if (this.mode === MODES.PLACE_BUILDING) {\n      const [mx, my] = mouseLocation;\n      const [tx, ty] = map.coordsToTile(mx, my);\n      const [x, y] = map.tileToCoords(tx, ty, false);\n\n      if (mouseLocation) {\n        this.drawPlaceBuilding = (drawer) => {\n          buildingTypes[this.placeBuildingBuilding].drawBuilding(\n            drawer,\n            x,\n            y,\n            Map.tileSize * 3,\n            Map.tileSize * 2,\n            this.color,\n            \"4\"\n          );\n        };\n      }\n\n      if (clickTarget[0] || clickTarget[1]) {\n        sound.play(\"click\");\n        this.placeBuildingForConstruction({\n          building: this.placeBuildingBuilding,\n          x,\n          y,\n          map,\n          unit: this.placeBuildingUnit,\n        });\n        this.cancelPlaceBuilding();\n      }\n    }\n  }\n\n  moveGroup(units, map, target, sound) {\n    const X_OFFSET = 70;\n    const Y_OFFSET = 70;\n    const MAX_ROW = 8;\n    units.forEach((unit, i) => {\n      const [x, y] = [\n        target[0] + (i % MAX_ROW) * X_OFFSET,\n        target[1] + Math.floor(i / MAX_ROW) * Y_OFFSET,\n      ];\n      unit.setPath([x, y], map);\n      this.moveFeedback.push({ x, y, time: 20 });\n      unit.state = STATES.MOVING;\n    });\n    sound.play(\"click\");\n  }\n\n  inMiniMap(click, clicked, drawer, camera) {\n    const miniMapX = clicked && click[0] - HUD.HUD_PADDING - camera.x;\n    const miniMapY =\n      clicked && click[1] - (drawer.height - 250 - HUD.HUD_PADDING) - camera.y;\n    return {\n      clicked:\n        miniMapX !== null &&\n        miniMapY !== null &&\n        miniMapX >= 0 &&\n        miniMapX < 250 &&\n        miniMapY >= 0 &&\n        miniMapY < 250,\n      x: miniMapX,\n      y: miniMapY,\n    };\n  }\n\n  inHud(click, clicked, drawer, camera) {\n    return (\n      clicked &&\n      click[1] - camera.y >=\n        drawer.height - HUD.HUD_HEIGHT - HUD.HUD_PADDING * 2\n    );\n  }\n\n  mouseActions({ camera, drawer, cpuPlayer, map, mines, mouse, sound }) {\n    const { clicked, rightClicked, clickTarget, rightClickTarget } = mouse;\n    if (this.inMiniMap(clickTarget, clicked, drawer, camera).clicked) {\n      console.log(\"minimap click\");\n      return;\n    }\n    if (\n      this.inMiniMap(rightClickTarget, rightClicked, drawer, camera).clicked\n    ) {\n      console.log(\"minimap right click\");\n      return;\n    }\n    if (this.inHud(clickTarget, clicked, drawer, camera)) {\n      console.log(\"hud click\");\n      return;\n    }\n    if (this.inHud(rightClickTarget, rightClicked, drawer, camera)) {\n      console.log(\"hud right click\");\n      return;\n    }\n\n    this.select(mouse, sound);\n\n    this.placeBuildingActions(map, mouse, sound);\n\n    const movingUnits = [];\n    this.units.forEach((unit) => {\n      if (!unit.selected) return;\n      if (this.unitActions({ cpuPlayer, map, mines, mouse, sound, unit })) {\n        movingUnits.push(unit);\n      }\n    });\n    if (movingUnits.length) {\n      this.moveGroup(movingUnits, map, rightClickTarget, sound);\n    }\n  }\n\n  tick({\n    camera,\n    cpuPlayer,\n    drawer,\n    map,\n    mines,\n    mouse,\n    particles,\n    sound,\n    targets,\n  }) {\n    this.mouseActions({ camera, cpuPlayer, drawer, map, mines, mouse, sound });\n\n    this.moveFeedback = this.moveFeedback\n      .map((mf) => ({ ...mf, time: mf.time - 1 }))\n      .filter((mf) => mf.time > 0);\n\n    Player.tick.call(this, { map, particles, sound, targets });\n  }\n\n  draw(drawer) {\n    if (this.mode === MODES.PLACE_BUILDING && this.drawPlaceBuilding) {\n      this.drawPlaceBuilding(drawer);\n    }\n\n    this.moveFeedback.forEach((mf) => {\n      if (mf.time % 10 >= 5) return;\n      drawer.ellipse({\n        ellipse: [mf.x, mf.y, 23, 13, 0, 0, 2 * Math.PI],\n        strokeColor: \"#4AC\",\n        strokeWidth: 5,\n      });\n    });\n\n    Player.draw.call(this, drawer);\n  }\n}\n\nexport default HumanPlayer;\n","class Keyboard {\n  constructor() {\n    document.addEventListener(\"keyup\", (event) => this.onKeyup(event));\n    document.addEventListener(\"keydown\", (event) => this.onKeydown(event));\n\n    this._pressed = {};\n\n    this.SPACE = { keyboard: [32], controller: [0, 1, 5, 7] };\n    this.LEFT = { keyboard: [37], controller: [14], dir: \"l\" };\n    this.UP = { keyboard: [38], controller: [12, 2, 3] };\n    this.RIGHT = { keyboard: [39], controller: [15], dir: \"r\" };\n    this.DOWN = { keyboard: [40], controller: [13] };\n  }\n\n  isDownControllerStick(dir) {\n    if (!navigator.getGamepads()[0]) return false;\n    const axes = navigator.getGamepads()[0].axes;\n\n    return {\n      l: axes[0] < 0,\n      r: axes[0] > 0,\n    }[dir];\n  }\n\n  isDownController(keyCode) {\n    if (!navigator.getGamepads()[0]) return false;\n\n    return navigator\n      .getGamepads()[0]\n      .buttons.reduce((acc, b, i) => (b.pressed ? acc.concat([i]) : acc), [])\n      .some((b) => keyCode.includes(b));\n  }\n\n  isDownKeyboard(keyCode) {\n    return keyCode.some((key) => this._pressed[key]);\n  }\n\n  isDown(keyCode) {\n    return (\n      this.isDownControllerStick(keyCode.dir) ||\n      this.isDownKeyboard(keyCode.keyboard) ||\n      this.isDownController(keyCode.controller) ||\n      false\n    );\n  }\n\n  onKeydown(event) {\n    this._pressed[event.keyCode] = true;\n  }\n\n  onKeyup(event) {\n    delete this._pressed[event.keyCode];\n  }\n}\n\nexport default Keyboard;\n","class Level {\n  constructor() {\n    this.defeat = false;\n    this.victory = false;\n  }\n\n  tick({ humanPlayer, cpuPlayer }) {\n    if (cpuPlayer.entities().length === 0) {\n      this.victory = true;\n    }\n    if (humanPlayer.entities().length === 0) {\n      this.defeat = true;\n    }\n  }\n\n  draw(drawer) {\n    const MESSAGE_WIDTH = 1000;\n    const MESSAGE_HEIGHT = 200;\n    const MESSAGE_Y_OFFSET = -100;\n    if (this.victory) {\n      drawer.rect({\n        adjusted: false,\n        rect: [\n          (drawer.width - MESSAGE_WIDTH) / 2,\n          (drawer.height - MESSAGE_HEIGHT) / 2 + MESSAGE_Y_OFFSET,\n          MESSAGE_WIDTH,\n          MESSAGE_HEIGHT,\n        ],\n        fillColor: \"#111\",\n      });\n      drawer.text({\n        fillColor: \"#EEE\",\n        text: \"VICTORY!\",\n        x: (drawer.width - MESSAGE_WIDTH) / 2 + 140,\n        y: (drawer.height - MESSAGE_HEIGHT) / 2 + 48 + MESSAGE_Y_OFFSET,\n        size: 20,\n      });\n    }\n    if (this.defeat) {\n      drawer.rect({\n        adjusted: false,\n        rect: [\n          (drawer.width - MESSAGE_WIDTH) / 2,\n          (drawer.height - MESSAGE_HEIGHT) / 2 + MESSAGE_Y_OFFSET,\n          MESSAGE_WIDTH,\n          MESSAGE_HEIGHT,\n        ],\n        fillColor: \"#111\",\n      });\n      drawer.text({\n        fillColor: \"#EEE\",\n        text: \"DEFEAT!\",\n        x: (drawer.width - MESSAGE_WIDTH) / 2 + 235,\n        y: (drawer.height - MESSAGE_HEIGHT) / 2 + 48 + MESSAGE_Y_OFFSET,\n        size: 20,\n      });\n    }\n  }\n}\n\nexport default Level;\n","const level = {\n  levelData:\n    \"////////4Af/4AAPwAD+AAAHgAD+AAADgAAAAAADgAAAAAABgAAAAAABwAAAAAABwAA8AAABwAD/gAAD4AD/gAAD/A//wAAD////4AAB//////gB//////gB//////gB/////+AB///wAAAB//4AAAAB/gAAAAAB8AAAAAAB4AAAAAAB4AAAAAABwAAAAAABwAAAAAAHgAAAAAAfgAAAAAH/gAAAAD//gAAAAP//gAAAA///gAAAB///gAAAD///gAAAH///gAAAH///gAAAH///gAAAH/8HwAAAP+ADwAAAP4ABwAAADgABwAAAAAABwAAAAAABwAAAAAAB4AAAAAAB8AAAAAAB/8AAAAAB//gAAAAD//4AAAAf////////\",\n  mines: [\n    [4, 2],\n    [38, 2],\n    [43, 37],\n    [11, 31],\n  ],\n  humanBases: [[4, 6]],\n  cpuBases: [\n    [38, 6],\n    [38, 37],\n    [12, 26],\n  ],\n  cpuShades: [\n    [43, 40],\n    [42, 3],\n    [42, 5],\n    [43, 42],\n    [14, 31],\n    [16, 31],\n    [18, 31],\n    [41, 41],\n    [41, 43],\n  ],\n  cpuGoblins: [\n    [35, 42],\n    [35, 44],\n    [33, 44],\n    [33, 42],\n    [33, 40],\n    [35, 40],\n    [31, 44],\n    [31, 42],\n    [31, 40],\n  ],\n  humanShades: [[7, 3]],\n  humanGoblins: [[9, 3]],\n};\n\nconst decode = (encoded, numRows = 48) => {\n  const decoded = atob(encoded);\n  const pad = (n) => \"00000000\".substr(n.length) + n;\n  const chars = decoded\n    .split(\"\")\n    .map((c) => pad(c.charCodeAt(0).toString(2)))\n    .join(\"\");\n  const re = new RegExp(`.{1,${numRows}}`, \"g\");\n  const rows = chars.match(re).map((r) => Array.from(r).map((c) => Number(c)));\n  return rows;\n};\n\nexport const TILE_TYPE = { NORMAL: \"NORMAL\", HOLE: \"HOLE\", MINE: \"MINE\" };\nexport const TILES = [TILE_TYPE.NORMAL, TILE_TYPE.HOLE, TILE_TYPE.MINE];\n\nclass Map {\n  constructor() {\n    this.loadLevel(level);\n  }\n\n  loadLevel(level) {\n    this.grid = decode(level.levelData, level.rows);\n    this.mines = level.mines;\n    this.humanBases = level.humanBases;\n    this.humanShades = level.humanShades;\n    this.humanGoblins = level.humanGoblins;\n    this.cpuBases = level.cpuBases;\n    this.cpuShades = level.cpuShades;\n    this.cpuGoblins = level.cpuGoblins;\n    this.height = this.grid.length;\n    this.width = this.grid[0].length;\n  }\n\n  tick() {}\n\n  coordsToTile(x, y) {\n    return [Math.floor(x / Map.tileSize), Math.floor(y / Map.tileSize)];\n  }\n\n  tileToCoords(x, y, middle = true) {\n    return [\n      x * Map.tileSize + (middle ? Map.tileSize / 2 : 0),\n      y * Map.tileSize + (middle ? Map.tileSize / 2 : 0),\n    ];\n  }\n\n  draw(drawer) {\n    this.grid.forEach((row, y) => {\n      let normalColor = !!(y % 2);\n      row.forEach((cell, x) => {\n        normalColor = !normalColor;\n        const tileType = TILES[cell];\n\n        const debug = false;\n        const debugColor = normalColor ? \"#ddd\" : \"#e6e6e6\";\n        const opacity = (((x ** 3 + y ** 2) % (3 * 16)) + 12 * 16).toString(16);\n        const color = debug ? debugColor : \"#202028\" + opacity;\n        if (tileType !== TILE_TYPE.HOLE) {\n          drawer.rect({\n            fillColor: color,\n            rect: [\n              x * Map.tileSizeX,\n              y * Map.tileSizeY,\n              Map.tileSizeX,\n              Map.tileSizeY,\n            ],\n          });\n        }\n      });\n    });\n  }\n}\n\nMap.mapAdjust = (x, y) => [\n  (x * Map.tileSizeX) / Map.tileSize,\n  (y * Map.tileSizeY) / Map.tileSize,\n];\n\nMap.size = 80 * 48;\nMap.tileSize = 80;\nMap.tileSizeX = 80;\nMap.tileSizeY = 80;\n\nexport default Map;\n","class Mine {\n  constructor(x, y) {\n    this.resources = 10000;\n    this.x = x;\n    this.y = y;\n    this.size = 80 * 2;\n    this.inFog = 0;\n  }\n\n  tick() {}\n\n  draw(drawer) {\n    drawer.rect({\n      fillColor: \"#338\",\n      rect: [this.x, this.y + this.size / 2, this.size, this.size / 2],\n    });\n    drawer.ellipse({\n      fillColor: \"#338\",\n      ellipse: [\n        this.x + this.size / 2,\n        this.y + this.size / 2,\n        this.size / 2,\n        this.size / 2,\n        0,\n        0,\n        2 * Math.PI,\n      ],\n    });\n\n    const DOOR_SIZE = 50;\n    drawer.rect({\n      fillColor: \"#111\",\n      rect: [\n        this.x + this.size / 2 - DOOR_SIZE / 2,\n        this.y + this.size - DOOR_SIZE / 2,\n        DOOR_SIZE,\n        DOOR_SIZE / 2,\n      ],\n    });\n    drawer.ellipse({\n      fillColor: \"#111\",\n      ellipse: [\n        this.x + this.size / 2,\n        this.y + this.size - DOOR_SIZE / 2,\n        DOOR_SIZE / 2,\n        DOOR_SIZE / 2,\n        0,\n        0,\n        2 * Math.PI,\n      ],\n    });\n\n    // hitbox?\n    const hitbox = false;\n    if (hitbox) {\n      drawer.rect({\n        fillColor: \"#caa\",\n        rect: [this.x, this.y, this.size, this.size],\n      });\n    }\n\n    if (!this.inFog) {\n      drawer.miniMap({\n        x: this.x,\n        y: this.y,\n        color: \"#69c\",\n        size: Math.ceil(this.size / 20),\n      });\n    }\n  }\n}\n\nexport default Mine;\n","import Map from \"./Map\";\nimport Mine from \"./Mine\";\n\nclass MineCollection {\n  constructor({ map }) {\n    this.mines = [];\n    map.mines.forEach(([x, y]) => {\n      this.mines.push(new Mine(x * Map.tileSize, y * Map.tileSize));\n    });\n  }\n\n  tick() {\n    this.mines.forEach((mine) => {\n      mine.tick();\n    });\n  }\n\n  draw(drawer) {\n    this.mines.forEach((mine) => {\n      mine.draw(drawer);\n    });\n  }\n}\n\nexport default MineCollection;\n","import HUD from \"./HUD\";\nimport Map from \"./Map\";\n\nconst minimapSize = 250;\n\nclass MiniMap {\n  constructor() {}\n\n  draw(drawer) {\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#666\",\n      rect: [\n        0,\n        drawer.height - minimapSize - HUD.HUD_PADDING * 2,\n        minimapSize + HUD.HUD_PADDING * 2,\n        minimapSize + HUD.HUD_PADDING * 2,\n      ],\n    });\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#111\",\n      rect: [\n        HUD.HUD_PADDING,\n        drawer.height - minimapSize - HUD.HUD_PADDING,\n        minimapSize,\n        minimapSize,\n      ],\n    });\n\n    const x =\n      (drawer.camera.position_x / Map.size) * minimapSize + HUD.HUD_PADDING;\n    const y =\n      drawer.height -\n      minimapSize +\n      (drawer.camera.position_y / ((Map.tileSizeY / Map.tileSize) * Map.size)) *\n        minimapSize -\n      HUD.HUD_PADDING;\n    drawer.rect({\n      adjusted: false,\n      strokeColor: \"#fff\",\n      rect: [\n        x,\n        y,\n        (drawer.width / Map.size) * minimapSize,\n        (drawer.height / ((Map.tileSizeY / Map.tileSize) * Map.size)) *\n          minimapSize,\n      ],\n    });\n\n    drawer.renderMiniMap();\n  }\n}\n\nexport default MiniMap;\n","const DRAG_THRESHOLD = 2;\n\nclass Mouse {\n  constructor() {\n    let canvas = document.querySelector(\"canvas\");\n    this.canvas = canvas;\n    this.canvas.addEventListener(\"click\", (event) => this.click(event));\n    this.canvas.addEventListener(\"mousedown\", (event) => this.mousedown(event));\n    this.canvas.addEventListener(\"mouseup\", (event) => this.mouseup(event));\n    this.canvas.addEventListener(\"mousemove\", (event) => this.mousemove(event));\n    this.canvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n      this.rightClick(event);\n    });\n    this.clickCoords = [null, null];\n    this.rightClickCoords = [null, null];\n    this.mouseLocation = [null, null];\n    this.mouseScreenLocation = [500, 500];\n\n    // dragging\n    this.dragging = false;\n    this.prevDragging = false;\n    this.releaseDrag = null;\n    this.startDragLocation = [null, null];\n  }\n\n  tick({ camera }) {\n    this.camera = camera;\n\n    this.releaseDrag = null;\n    if (this.prevDragging && !this.dragging) {\n      if (\n        Math.abs(this.startDragLocation[0] - this.mouseLocation[0]) >\n          DRAG_THRESHOLD ||\n        Math.abs(this.startDragLocation[1] - this.mouseLocation[1]) >\n          DRAG_THRESHOLD\n      ) {\n        this.releaseDrag = this.startDragLocation.concat(this.mouseLocation);\n        this.startDragLocation = [null, null];\n      }\n    }\n    this.prevDragging = this.dragging;\n\n    this.clickTarget = this.clickCoords;\n    this.clicked = this.clickTarget[0] || this.clickTarget[1];\n    this.rightClickTarget = this.rightClickCoords;\n    this.rightClicked = this.rightClickTarget[0] || this.rightClickTarget[1];\n    this.clickCoords = this.rightClickCoords = [null, null];\n  }\n\n  click({ clientX, clientY }) {\n    this.clickCoords = [clientX + this.camera.x, clientY + this.camera.y];\n  }\n\n  mousedown({ clientX, clientY, which }) {\n    if (which === 1) {\n      this.startDragLocation = [\n        clientX + this.camera.x,\n        clientY + this.camera.y,\n      ];\n      this.dragging = true;\n    }\n  }\n\n  mouseup() {\n    this.dragging = false;\n  }\n\n  mousemove({ clientX, clientY }) {\n    if (this.camera) {\n      this.mouseLocation = [clientX + this.camera.x, clientY + this.camera.y];\n      this.mouseScreenLocation = [clientX, clientY];\n    }\n  }\n\n  rightClick({ clientX, clientY }) {\n    this.rightClickCoords = [clientX + this.camera.x, clientY + this.camera.y];\n  }\n\n  draw(drawer) {\n    if (this.dragging) {\n      drawer.rect({\n        rect: [\n          this.startDragLocation[0],\n          this.startDragLocation[1],\n          this.mouseLocation[0] - this.startDragLocation[0],\n          this.mouseLocation[1] - this.startDragLocation[1],\n        ],\n        strokeColor: \"#369\",\n      });\n    }\n  }\n}\n\nexport default Mouse;\n","import particleTypes from \"./particleTypes\";\n\nclass Particle {\n  constructor(type, x, y, dx, dy, color) {\n    const template = particleTypes[type];\n\n    this.type = type;\n    this.startingY = y;\n    this.x = x;\n    this.y = y;\n    this.dx = dx;\n    this.dy = dy;\n    this.color = color;\n    this.stuck = false;\n    this.invisible = false;\n    this.grav = 0.6;\n    this.particleDraw = template.draw;\n  }\n\n  stick({ map }) {\n    const [x, y] = map.coordsToTile(this.x, this.y);\n    const tile = map.grid[y][x];\n    if (tile) this.invisible = true;\n    this.stuck = true;\n  }\n\n  tick({ map }) {\n    if (this.stuck) return;\n    this.x += this.dx;\n    this.dy += this.grav;\n    this.y += this.dy;\n\n    if (this.y - Math.random() * 10 > this.startingY) this.stick({ map });\n  }\n\n  draw(drawer) {\n    if (this.invisible) return;\n    this.particleDraw.call(this, drawer);\n  }\n}\n\nexport default Particle;\n","const MAX_PARTICLES = 5000;\n\nclass ParticleCollection {\n  constructor() {\n    this.particles = [];\n  }\n\n  add(particle) {\n    this.particles.push(particle);\n  }\n\n  tick({ map }) {\n    if (this.particles.length > MAX_PARTICLES) {\n      this.particles = this.particles.slice(\n        this.particles.length - MAX_PARTICLES\n      );\n    }\n    this.particles.forEach((particle) => particle.tick({ map }));\n  }\n\n  draw(drawer) {\n    this.particles.forEach((particle) => particle.draw(drawer));\n  }\n}\n\nexport default ParticleCollection;\n","import Building from \"./Building\";\nimport Unit, { STATES } from \"./Unit\";\nimport buildingTypes from \"./buildingTypes\";\nimport unitTypes from \"./unitTypes\";\n\nclass Player {\n  constructor() {\n    this.resources = 500;\n\n    this.units = [];\n\n    this.buildings = [];\n  }\n\n  addUnit({ type, x, y }) {\n    const unitType = unitTypes[type];\n    const colors = unitType.colors(this.color);\n    const newUnit = new Unit(x, y, {\n      ...unitType,\n      colors,\n      miniMapColor: this.miniMapColor,\n    });\n    this.units.push(newUnit);\n  }\n\n  addBuilding({ type, x, y, built = true, unit = null }) {\n    const building = buildingTypes[type];\n    const newBuilding = new Building(\n      x,\n      y,\n      building,\n      this.color,\n      built,\n      unit,\n      this.miniMapColor\n    );\n    this.buildings.push(newBuilding);\n    return newBuilding;\n  }\n\n  cancelBuilding(building) {\n    building.builder.buildingTarget = null;\n    building.builder.state = STATES.IDLE;\n    this.buildings = this.buildings.filter((b) => b !== building);\n    this.resources += building.cost;\n  }\n\n  placeBuildingForConstruction({ building, x, y, map, unit }) {\n    const b = this.addBuilding({ type: building, x, y, built: false, unit });\n    this.resources -= b.cost;\n    unit.buildBuilding({ building: b });\n  }\n\n  entities() {\n    return this.units.concat(this.buildings);\n  }\n\n  static tick({ map, particles, sound, targets }) {\n    this.units.forEach((u) =>\n      u.tick({ particles, map, player: this, sound, targets })\n    );\n    this.units = this.units.reduce((units, unit) => {\n      if (unit.health <= 0) {\n        unit.explode({ particles, sound });\n        if (this.selected && this.selected.includes(unit)) {\n          this.selected = this.selected.filter((u) => u !== unit);\n        }\n      } else {\n        units.push(unit);\n      }\n      return units;\n    }, []);\n    this.buildings.forEach((b) => b.tick({ player: this }));\n    this.buildings = this.buildings.reduce((buildings, building) => {\n      if (building.health <= 0) {\n        building.explode({ particles, sound });\n        if (this.selected && this.selected.includes(building)) {\n          this.selected = this.selected.filter((u) => u !== building);\n        }\n      } else {\n        buildings.push(building);\n      }\n      return buildings;\n    }, []);\n  }\n\n  static draw(drawer) {\n    this.buildings.forEach((b) => b.draw(drawer));\n    this.units.forEach((u) => u.draw(drawer));\n  }\n}\n\nexport default Player;\n","import { zzfx } from \"zzfx\";\n\n// prettier-ignore\nlet sounds = {\n  \"death\": [2.45,,608,.02,.09,.38,2,1.24,.6,,,,,.3,,.4,.03,.51,.05],\n  \"gun\": [0.4,0,0,,,0,4,0,500,,,,,,,.1,,0,.15],\n  \"jump\": [,,131,.02,.02,.08,,1.49,2.3,,,,,,,,,.9,.1],\n  \"message\": [2,0,1740,,.06,.29,,.77,,,,,,,,,,.76,.07,.06],\n  \"minigun\": [0.6,0,0,,,0,4,0,1e8,,,,,,,.04,,0,.08],\n  \"pickup\": [,,548,.08,.36,.47,1,1.79,,,236,.03,.08,,,,,.83],\n  \"shotgun\": [0.8,,300,,,.9,4,.5,,,,,,10,74,.2,,2],\n  \"sniper\": [0.8,,300,,,1.2,4,.5,,,,,,10,74,.1,,2],\n  \"thrown\": [1,0,0,,,0,4,0,1e8,,,,,,,.055,,0,.3],\n\n  \"click\": [0.5,,555,.01,.02,.01,3,.11,,98,-816,.01,.02,,,,,.43,,.02],\n};\n\nexport default class Sound {\n  constructor() {\n    this.volume = 1;\n  }\n\n  play(sound, volume) {\n    const newSound = [...sounds[sound]];\n    if (volume) newSound[0] *= volume * this.volume;\n    zzfx(...newSound);\n  }\n\n  setGlobalVolume(volume) {\n    this.volume = volume;\n  }\n}\n","export const humanoid = (x, y, facing, colors, options = {}) => {\n  let { skin, eyes, body } = colors;\n  let parts = [];\n\n  if (options.blink) {\n    eyes = \"#0000\";\n  }\n\n  let head;\n  if (options.brute) {\n    head = [\n      [skin, [0, -1, 6, 3]],\n      [skin, [1, -2, 4, 5]],\n    ]; // head\n  } else {\n    head = [[skin, [0, 0, 5, 3]]]; // head\n  }\n  parts = parts.concat(head);\n\n  let upper = [\n    [eyes, [1 + (options.brute ? 1 : 0), 1, 1, 1]], // eye left\n    [eyes, [4, 1, 1, 1]], // eye right\n  ];\n  parts = parts.concat(upper);\n\n  let lower = [\n    [body, [0, 4, 3, 1]], // body\n    [skin, [0, 4, 1, 1]], // left arm\n    [skin, [3, 4, 1, 1]], // right arm\n  ];\n\n  if (!options.bodyless) {\n    parts = parts.concat(lower);\n  }\n\n  if (options.horns)\n    parts = parts.concat([\n      [skin, [0, -1, 1, 1]], // horn left\n      [skin, [4, -1, 1, 1]], // horn right\n    ]);\n\n  if (options.antenna)\n    parts = parts.concat([\n      [skin, [1, -1, 1, 1]], // antenna left\n      [skin, [0, -2, 1, 1]], // antenna left\n      [skin, [3, -1, 1, 1]], // antenna right\n      [skin, [4, -2, 1, 1]], // antenna right\n      [eyes, [2, 1, 1, 1]], // eye leftmiddle\n      [eyes, [3, 1, 1, 1]], // eye rightmiddle\n    ]);\n\n  const mult = options.size || 8;\n  // prettier-ignore\n  parts = parts.map(([c, r]) => ({\n    c,\n    r: [\n      facing === 1 ? x + (r[0] * mult) : 5 * mult - ((r[0] + r[2]) * mult) + x,\n      r[1] * mult + y,\n      r[2] * mult,\n      r[3] * mult\n    ],\n  }));\n\n  return parts;\n};\n","import AStarFinder, { Grid, smoothenPath } from \"./AStar\";\nimport HUD from \"./HUD\";\nimport { humanoid } from \"./Sprites\";\nimport Particle from \"./Particle\";\nimport buildingTypes from \"./buildingTypes\";\nimport unitTypes from \"./unitTypes\";\nimport { boxCollision } from \"./collision\";\nimport { distance } from \"./distance\";\n\nexport const STATES = {\n  IDLE: 0,\n  MOVING: 1,\n  ATTACKING: 2,\n  MINING: 3,\n  RETURNING_RESOURCE: 4,\n  BUILD_BUILDING: 5,\n};\n\nconst MENU_STATES = {\n  INITIAL: 0,\n  BUILDING: 1,\n  PLACE_BUILDING: 2,\n};\n\nclass Unit {\n  constructor(x, y, unitType) {\n    Object.entries(unitType).forEach(([key, value]) => {\n      this[key] = value;\n    });\n\n    this.x = x;\n    this.y = y;\n    this.pathY = y;\n    this.dx = 0;\n    this.dy = 0;\n    this.maxHealth = this.health;\n    this.lifespan = 0;\n    this.selected = false;\n    this.path = [];\n    this.facing = 1;\n    this.type = \"unit\";\n    this.bounce = 0;\n    this.bounceTime = 0;\n    this.blink = 0;\n    this.target = null;\n    this.attackSelected = 0;\n    this.recalculateTarget = 0;\n    this.state = STATES.IDLE;\n    this.menuState = MENU_STATES.INITIAL;\n    this.inFog = 0;\n\n    // worker things\n    this.carryingResource = false;\n    this.miningTarget = null;\n    this.baseTarget = null;\n    this.buildingTarget = null;\n\n    this.cooldownTime = 0;\n    this.firingTime = 0;\n  }\n\n  attacked() {\n    this.attackSelected = 30;\n  }\n\n  setPath(target, map) {\n    const [targetX, targetY] = target;\n    if (this.flying) {\n      this.path = [target];\n      return true;\n    }\n\n    const [startX, startY] = map.coordsToTile(this.x, this.pathY);\n    const [endX, endY] = map.coordsToTile(targetX, targetY);\n\n    const finder = new AStarFinder();\n    const grid = new Grid(map.grid);\n    const p = finder.findPath(startX, startY, endX, endY, grid);\n\n    if (p.length === 0) return false;\n    const smoothPath = smoothenPath(grid, p);\n\n    const path = smoothPath\n      .map(([x, y]) => map.tileToCoords(x, y))\n      .slice(1, -1)\n      .concat([target]);\n\n    this.path = path;\n\n    return true;\n  }\n\n  setTarget(enemy, map) {\n    this.target = enemy;\n    this.state = STATES.ATTACKING;\n    this.recalculateTarget = 15;\n    this.target.attacked();\n\n    const distanceFromTarget = distance(this, this.target);\n    const targetInRange = distanceFromTarget <= this.range;\n    if (!targetInRange) {\n      this.setPath([this.target.x, this.target.y], map);\n    }\n  }\n\n  setMining(mine) {\n    this.path = [];\n    this.miningTarget = mine;\n    this.state = STATES.MINING;\n  }\n\n  buildBuilding({ building }) {\n    this.buildingTarget = building;\n    this.state = STATES.BUILD_BUILDING;\n  }\n\n  calculateSpeed() {\n    let [targetX, targetY] = this.path[0];\n    let d = distance({ x: this.x, y: this.pathY }, { x: targetX, y: targetY });\n\n    // if close enough to destination, remove waypoint\n    if (d > this.speed) {\n      this.dx = this.speed * ((targetX - this.x) / Math.abs(d));\n      this.dy = this.speed * ((targetY - this.pathY) / Math.abs(d));\n    } else {\n      this.path.shift();\n    }\n  }\n\n  takeDamage(amount, { particles, d }) {\n    this.health -= amount;\n    for (let i = 0; i < amount; i++) {\n      particles.add(\n        new Particle(\n          \"blood\",\n          this.x,\n          this.y + this.size / 2,\n          Math.random() * 6 - 3 + d.dx * 4,\n          Math.random() * -10 - 5 + d.dy * 4,\n          this.bloodColor\n        )\n      );\n    }\n    return this.health <= 0;\n  }\n\n  explode({ particles, sound }) {\n    sound.play(\"death\");\n    for (let i = 0; i < 100; i++) {\n      particles.add(\n        new Particle(\n          \"blood\",\n          this.x,\n          this.y,\n          Math.random() * 10 - 5,\n          Math.random() * -12 - 6,\n          this.bloodColor\n        )\n      );\n    }\n    for (let i = 0; i < 5; i++) {\n      particles.add(\n        new Particle(\n          \"chunk\",\n          this.x,\n          this.y,\n          Math.random() * 6 - 3,\n          Math.random() * -6 - 6,\n          \"red\"\n        )\n      );\n    }\n  }\n\n  returnResource(player, map, baseTarget = null) {\n    this.path = [];\n    let base = baseTarget;\n    if (!base) {\n      const bases = player.buildings.filter((b) => b.name === \"base\");\n      if (bases.length) {\n        bases.sort((a, b) => distance(this, a) - distance(this, b));\n        base = bases[0];\n      }\n    }\n    if (base) {\n      this.baseTarget = base;\n      this.setPath([base.x + base.sizeX / 2, base.y + base.sizeY / 2], map);\n      this.state = STATES.RETURNING_RESOURCE;\n    }\n  }\n\n  move() {\n    if (this.path.length) {\n      this.calculateSpeed();\n      this.facing = this.dx > 0 ? 1 : 0;\n    } else {\n      this.dx = 0;\n      this.dy = 0;\n      if (this.state === STATES.MOVING) this.state = STATES.IDLE;\n    }\n    this.x += this.dx;\n    this.pathY += this.dy;\n  }\n\n  tick({ map, particles, player, sound, targets }) {\n    this.lifespan += 1;\n\n    // blink\n    if (Math.random() < 0.005) {\n      this.blink = 10;\n    }\n    if (this.blink > 0) {\n      this.blink -= 1;\n    }\n\n    if (this.state === STATES.IDLE && Math.random() < 0.001) {\n      this.facing = this.facing ? 0 : 1;\n    }\n\n    // bounce\n    if (this.bouncy) {\n      const BOUNCE_HEIGHT = 12;\n      const BOUNCE_DURATION = 12;\n      const shouldMoveBounce =\n        (this.state === STATES.MOVING || this.state === STATES.ATTACKING) &&\n        this.bounceTime === 0;\n      const shouldIdleBounce =\n        this.state === STATES.IDLE && Math.random() < 0.01;\n      if (shouldMoveBounce || shouldIdleBounce) {\n        this.bounceTime = BOUNCE_DURATION;\n      }\n      if (this.bounceTime > 0) {\n        this.bounceTime -= 1;\n        const a =\n          BOUNCE_DURATION * (Math.sqrt(BOUNCE_HEIGHT) / (BOUNCE_HEIGHT * 2));\n        this.bounce =\n          -Math.pow(this.bounceTime / a - Math.sqrt(BOUNCE_HEIGHT), 2) +\n          BOUNCE_HEIGHT;\n      }\n    }\n\n    // building\n    if (this.state === STATES.BUILD_BUILDING) {\n      if (this.path.length === 0) {\n        this.setPath(\n          [\n            this.buildingTarget.x + this.buildingTarget.sizeX / 2,\n            this.buildingTarget.y + this.buildingTarget.sizeY / 2,\n          ],\n          map\n        );\n      }\n      if (boxCollision(this.hitbox(), this.buildingTarget)) {\n        this.buildingTarget.buildingProgress -= 1;\n        if (this.buildingTarget.buildingProgress <= 0) {\n          this.buildingTarget.built = true;\n          this.state = STATES.IDLE;\n          this.menuState = MENU_STATES.INITIAL;\n        }\n      }\n    }\n\n    // mining\n    if (this.state === STATES.MINING) {\n      if (!this.carryingResource && this.path.length === 0) {\n        this.setPath(\n          [\n            this.miningTarget.x + this.miningTarget.size / 2,\n            this.miningTarget.y + this.miningTarget.size / 2,\n          ],\n          map\n        );\n      } else if (this.carryingResource) {\n        this.returnResource(player, map);\n      }\n      if (boxCollision(this.hitbox(), this.miningTarget)) {\n        this.carryingResource = true;\n        this.returnResource(player, map);\n      }\n    }\n    if (this.state === STATES.RETURNING_RESOURCE) {\n      if (\n        boxCollision(this.hitbox(), this.baseTarget) &&\n        this.carryingResource\n      ) {\n        player.resources += 10;\n        this.carryingResource = false;\n        this.setPath(\n          [\n            this.miningTarget.x + this.miningTarget.size / 2,\n            this.miningTarget.y + this.miningTarget.size / 2,\n          ],\n          map\n        );\n        this.state = STATES.MINING;\n      }\n    }\n\n    // find targets while idle\n    if (this.aggro && this.state === STATES.IDLE) {\n      const [nearTarget] = targets.filter(\n        (entity) => distance(this, entity) <= this.range\n      );\n      if (nearTarget) {\n        this.setTarget(nearTarget, map);\n      }\n    }\n\n    // attacking\n    if (this.target && this.target.health <= 0) {\n      this.target = null;\n      this.state = STATES.IDLE;\n      this.path = [];\n    }\n    if (this.firingTime > 0) this.firingTime -= 1;\n    if (this.cooldownTime > 0) this.cooldownTime -= 1;\n    if (this.state === STATES.ATTACKING) {\n      const distanceFromTarget = distance(this, this.target);\n      const targetInRange = distanceFromTarget <= this.range;\n\n      this.recalculateTarget -= 1;\n      if (this.recalculateTarget < 0 && !targetInRange) {\n        this.setPath([this.target.x, this.target.y], map);\n        this.recalculateTarget = 15;\n      }\n\n      if (targetInRange && this.cooldownTime === 0) {\n        sound.play(this.attackSound);\n        this.cooldownTime = this.cooldownTotalTime;\n        this.firingTime = this.firingTotalTime;\n        this.path = [];\n\n        const d = distance(this, this.target);\n        const dx = (this.target.x - this.x) / d;\n        const dy = (this.target.y - this.pathY) / d;\n        this.target.takeDamage(this.damage, {\n          particles,\n          d: { dx, dy },\n        });\n      }\n    }\n\n    if (this.firingTime === 0) {\n      this.move();\n    }\n    this.y = this.pathY - this.bounce;\n\n    if (this.attackSelected > 0) this.attackSelected -= 1;\n  }\n\n  actions({ player }) {\n    const output = Array(9).fill({});\n\n    const cancel = {\n      name: \"cancel\",\n      cost: 0,\n      actionable: () => true,\n      drawIcon: HUD.cancelIcon,\n      execute: () => {\n        this.menuState = MENU_STATES.INITIAL;\n        player.cancelPlaceBuilding();\n        if (this.buildingTarget) {\n          player.cancelBuilding(this.buildingTarget);\n        }\n        this.state = STATES.IDLE;\n      },\n    };\n\n    const buildBuilding = (building) => ({\n      name: `build ${building[\"name\"]}`,\n      cost: building[\"cost\"],\n      actionable: function () {\n        return this.cost <= player.resources;\n      },\n      drawIcon: (drawer, x, y) => {\n        if (building[\"name\"] === \"base\") {\n          drawer.rect({\n            adjusted: false,\n            rect: [x + 14, y + 12, 7, 35],\n            fillColor: \"#666\",\n          });\n          drawer.rect({\n            adjusted: false,\n            rect: [x + 21, y + 13, 25, 18],\n            fillColor: \"#0f0\",\n          });\n        }\n        if (building[\"name\"] === \"barracks\") {\n          const sx = 11.5;\n          const sy = 13;\n          drawer.ellipse({\n            adjusted: false,\n            ellipse: [x + sx, y + sy, 36, 36, 0, 0, Math.PI / 3],\n            fillColor: \"#0f0\",\n          });\n          drawer.ellipse({\n            adjusted: false,\n            ellipse: [\n              x + sx + 36,\n              y + sy,\n              36,\n              36,\n              0,\n              (2 * Math.PI) / 3,\n              (3 * Math.PI) / 3,\n            ],\n            fillColor: \"#0f0\",\n          });\n          drawer.lines({\n            adjusted: false,\n            lines: [\n              [x + sx, y + sy],\n              [x + sx + 36, y + sy],\n              [x + sx + 18, y + sy + (36 * 3 ** (1 / 2)) / 2],\n            ],\n            fillColor: \"#0f0\",\n          });\n        }\n      },\n      execute: () => {\n        player.placeBuildingMode({ unit: this, building: building[\"name\"] });\n        this.menuState = MENU_STATES.PLACE_BUILDING;\n      },\n    });\n\n    if (this.state === MENU_STATES.BUILD_BUILDING) {\n      output[5] = cancel;\n    } else if (this.menuState === MENU_STATES.BUILDING) {\n      output[0] = buildBuilding(buildingTypes[\"base\"]);\n      output[1] = buildBuilding(buildingTypes[\"barracks\"]);\n      output[5] = cancel;\n    } else if (this.menuState === MENU_STATES.PLACE_BUILDING) {\n      output[5] = cancel;\n    } else {\n      output[0] = {\n        name: \"move\",\n        cost: 0,\n        actionable: () => true,\n        drawIcon: (drawer, x, y) => {\n          drawer.ellipse({\n            adjusted: false,\n            ellipse: [x + 30, y + 30, 23, 23, 0, 0, 2 * Math.PI],\n            strokeColor: \"#0F0\",\n            strokeWidth: 5,\n          });\n          drawer.triangle({\n            adjusted: false,\n            x: x + 30,\n            y: y + 22,\n            fillColor: \"#0F0\",\n            rotation: Math.PI * 0.75,\n            size: 15,\n          });\n          drawer.rect({\n            adjusted: false,\n            rect: [x + 14, y + 26, 25, 7],\n            fillColor: \"#0F0\",\n          });\n        },\n        execute: () => {\n          console.log(\"move\");\n        },\n      };\n      if (this.builder) {\n        output[3] = {\n          name: \"build\",\n          cost: 0,\n          actionable: () => true,\n          drawIcon: (drawer, x, y) => {\n            drawer.triangle({\n              adjusted: false,\n              x: x + 17,\n              y: y + 18,\n              fillColor: \"#0F0\",\n              rotation: Math.PI * 0.25,\n              size: 26,\n            });\n            drawer.rect({\n              adjusted: false,\n              rect: [x + 18, y + 25, 24, 20],\n              fillColor: \"#0F0\",\n            });\n            drawer.rect({\n              adjusted: false,\n              rect: [x + 26, y + 37, 7, 8],\n              fillColor: \"#111\",\n            });\n          },\n          execute: () => {\n            this.menuState = MENU_STATES.BUILDING;\n          },\n        };\n      }\n    }\n    return output;\n  }\n\n  hudDrawIcon(drawer, x, y, name) {\n    const options = unitTypes[name];\n    Unit.hudDrawIcon(drawer, x, y, { ...options, bodyless: this.bodyless });\n  }\n\n  hudDraw(drawer, x, y, name) {\n    const options = unitTypes[name];\n    const colors = {\n      skin: \"#0f0\",\n      eyes: \"#666\",\n      body: \"#666\",\n    };\n    humanoid(x, y, 1, colors, { ...options, size: 12 }).forEach(({ c, r }) =>\n      drawer.rect({\n        adjusted: false,\n        fillColor: c,\n        rect: r,\n      })\n    );\n  }\n\n  hitbox() {\n    const x = this.x - this.size / 2;\n    const y = this.y - this.size / 2;\n    return { x, y, size: this.size };\n  }\n\n  draw(drawer) {\n    const x = this.x - this.size / 2;\n    const y = this.y - this.size / 2;\n\n    const drawRing = (color) => {\n      drawer.ellipse({\n        ellipse: [\n          x + this.size / 2,\n          y + this.size,\n          (this.size + 15) / 2,\n          this.size / 3,\n          0,\n          0,\n          2 * Math.PI,\n        ],\n        strokeColor: color,\n        strokeWidth: 5,\n      });\n    };\n    if (this.selected) drawRing(\"#4AC\");\n    if (this.attackSelected > 0 && this.attackSelected % 10 > 5)\n      drawRing(\"#A00\");\n\n    humanoid(x, y, this.facing, this.colors, {\n      bodyless: this.bodyless,\n      brute: this.brute,\n      horns: this.horns,\n      antenna: this.antenna,\n\n      blink: this.blink > 0,\n      size: this.size / 5,\n    }).forEach(({ c, r }) =>\n      drawer.rect({\n        fillColor: c,\n        rect: r,\n      })\n    );\n\n    if (this.carryingResource) {\n      drawer.draw(() => {\n        drawer.rect({\n          fillColor: \"#39ca\",\n          rect: [x + (this.facing ? 5 : -35) + this.size / 2, y + 10, 30, 30],\n          rotation: Math.PI * -0.05,\n          size: 30,\n        });\n      });\n    }\n\n    if (this.firingTotalTime - this.firingTime < 5) {\n      // prettier-ignore\n      [\n        [(this.facing === 1 ? 8 : -1), 3, 1, 1],\n        [(this.facing === 1 ? 7 : 0), 4, 2, 3],\n      ].forEach(([sx, sy, dx, dy]) =>\n        drawer.rect({\n          fillColor: \"yellow\",\n          rect: [x + sx * 6, y + sy * 6, dx * 6, dy * 6],\n        })\n      );\n\n      // prettier-ignore\n      [\n        [(this.facing === 1 ? 8 : -1), 4, 2, 2],\n        [(this.facing === 1 ? 10 : -3), 4, 1, 1],\n      ].forEach(([sx, sy, dx, dy]) =>\n        drawer.rect({\n          fillColor: \"white\",\n          rect: [x + sx * 6, y + sy * 6, dx * 6, dy * 6],\n        })\n      );\n    }\n\n    const hitbox = false;\n    if (hitbox) {\n      const hb = this.hitbox();\n      drawer.rect({\n        fillColor: \"#c668\",\n        rect: [hb.x, hb.y, hb.size, hb.size],\n      });\n    }\n\n    if (!this.inFog) {\n      drawer.miniMap({\n        x: x,\n        y: y,\n        color: this.miniMapColor,\n        size: Math.ceil(this.size / 20),\n      });\n    }\n  }\n}\n\nUnit.hudDrawIcon = (drawer, x, y, options) => {\n  const colors = {\n    skin: \"#0f0\",\n    eyes: \"#666\",\n    body: \"#666\",\n  };\n  humanoid(x + 14, y + 18, 1, colors, { ...options, size: 6 }).forEach(\n    ({ c, r }) =>\n      drawer.rect({\n        adjusted: false,\n        fillColor: c,\n        rect: r,\n      })\n  );\n};\n\nexport default Unit;\n","import Map from \"./Map\";\nimport Unit from \"./Unit\";\nimport unitTypes from \"./unitTypes\";\n\nconst buildUnit = (type, building, player) => {\n  const { name, cost, buildTime } = unitTypes[type];\n  return {\n    name: `build ${name}`,\n    cost: cost,\n    time: buildTime,\n    actionable: function () {\n      return this.cost <= player.resources;\n    },\n    execute: function ({ player }) {\n      if (building.tasks.length < 5 && player.resources >= this.cost) {\n        player.resources -= this.cost;\n        building.queueTask(this, { player });\n        return true;\n      }\n      return false;\n    },\n    complete: ({ player }) => {\n      player.addUnit({\n        type,\n        x: building.x + building.sizeX + 10,\n        y: building.y + building.sizeY + 10,\n      });\n    },\n    drawIcon: (drawer, x, y) => {\n      const options = unitTypes[name];\n      Unit.hudDrawIcon(drawer, x, y, options);\n    },\n  };\n};\n\nconst drawBuilding = (\n  drawer,\n  x,\n  y,\n  width,\n  height,\n  color,\n  opacity = \"F\",\n  accessory\n) => {\n  drawer.rect({\n    fillColor: \"#544\" + opacity,\n    rect: [x, y + Map.tileSize, width, height],\n  });\n\n  drawer.ellipse({\n    ellipse: [\n      x + width / 2,\n      y + height + Map.tileSize,\n      width / 2,\n      height / 4,\n      0,\n      0,\n      2 * Math.PI,\n    ],\n    fillColor: \"#544\" + opacity,\n  });\n\n  drawer.ellipse({\n    ellipse: [\n      x + width / 2,\n      y + Map.tileSize,\n      width / 2,\n      height / 4,\n      0,\n      0,\n      2 * Math.PI,\n    ],\n    fillColor: \"#655\" + opacity,\n  });\n\n  if (accessory === \"flag\") {\n    const FLAGPOLE_WIDTH = 10;\n    const FLAGPOLE_HEIGHT = 100;\n    drawer.rect({\n      fillColor: \"#666\" + opacity,\n      rect: [\n        x + width / 2 - FLAGPOLE_WIDTH / 2,\n        y - FLAGPOLE_HEIGHT + Map.tileSize,\n        FLAGPOLE_WIDTH,\n        FLAGPOLE_HEIGHT,\n      ],\n    });\n    drawer.rect({\n      fillColor: color + opacity,\n      rect: [\n        x + width / 2 + FLAGPOLE_WIDTH / 2,\n        y - FLAGPOLE_HEIGHT + Map.tileSize,\n        60,\n        40,\n      ],\n    });\n  }\n\n  if (accessory === \"shield\") {\n    const sx = 70;\n    const sy = 150;\n    drawer.ellipse({\n      ellipse: [x + sx, y + sy, 100, 100, 0, 0, Math.PI / 3],\n      fillColor: color + opacity,\n    });\n    drawer.ellipse({\n      ellipse: [\n        x + sx + 100,\n        y + sy,\n        100,\n        100,\n        0,\n        (2 * Math.PI) / 3,\n        (3 * Math.PI) / 3,\n      ],\n      fillColor: color + opacity,\n    });\n    drawer.lines({\n      lines: [\n        [x + sx, y + sy],\n        [x + sx + 100, y + sy],\n        [x + sx + 50, y + sy + (100 * 3 ** (1 / 2)) / 2],\n      ],\n      fillColor: color + opacity,\n    });\n  }\n};\nexport default {\n  base: {\n    name: \"base\",\n    health: 50,\n    buildTime: 600,\n    cost: 400,\n    sizeX: Map.tileSize * 3,\n    sizeY: Map.tileSize * 3,\n    actions: ({ building, output, player }) => {\n      output[0] = buildUnit(\"shade\", building, player);\n    },\n    drawBuilding: (...args) => drawBuilding(...args, \"flag\"),\n  },\n  barracks: {\n    name: \"barracks\",\n    health: 50,\n    buildTime: 300,\n    cost: 150,\n    sizeX: Map.tileSize * 3,\n    sizeY: Map.tileSize * 3,\n    actions: ({ building, output, player }) => {\n      output[0] = buildUnit(\"goblin\", building, player);\n      output[1] = buildUnit(\"brute\", building, player);\n      output[2] = buildUnit(\"speeder\", building, player);\n    },\n    drawBuilding: (...args) => drawBuilding(...args, \"shield\"),\n  },\n};\n","export const boxCollision = (rect1, rect2) =>\n  rect1.x < rect2.x + (rect2.size || rect2.sizeX) &&\n  rect1.x + (rect1.size || rect1.sizeX) > rect2.x &&\n  rect1.y < rect2.y + (rect2.size || rect2.sizeY) &&\n  (rect1.size || rect1.sizeY) + rect1.y > rect2.y;\n\nexport const pointCollision = (rect, point) =>\n  point.x >= rect.x &&\n  point.x < rect.x + (rect.size || rect.sizeX) &&\n  point.y >= rect.y &&\n  point.y < rect.y + (rect.size || rect.sizeY);\n","export const distance = (source, dest) => {\n  const dx = Math.abs(source.x - dest.x);\n  const dy = Math.abs(source.y - dest.y);\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n","import Background from \"./Background\";\nimport CPUPlayer from \"./CPUPlayer\";\nimport Drawer from \"./Drawer\";\nimport FogOfWar from \"./FogOfWar\";\nimport Keyboard from \"./Keyboard\";\nimport HUD from \"./HUD\";\nimport HumanPlayer from \"./HumanPlayer\";\nimport Level from \"./Level\";\nimport Map from \"./Map\";\nimport MineCollection from \"./MineCollection\";\nimport MiniMap from \"./MiniMap\";\nimport Mouse from \"./Mouse\";\nimport ParticleCollection from \"./ParticleCollection\";\nimport Sound from \"./Sound\";\n\nlet fps = 60,\n  interval = 1000 / fps,\n  lastTime = 0,\n  delta = 0;\n\nwindow.onload = () => {\n  let drawer = new Drawer();\n\n  let background = new Background({\n    cw: drawer.canvas.width,\n    ch: drawer.canvas.height,\n  });\n  let keyboard = new Keyboard();\n  let mouse = new Mouse();\n  let sound = new Sound();\n\n  let fogOfWar = new FogOfWar();\n  let hud = new HUD();\n  let level = new Level();\n  let map = new Map();\n  let mines = new MineCollection({ map });\n  let miniMap = new MiniMap();\n  let humanPlayer = new HumanPlayer({ map });\n  let cpuPlayer = new CPUPlayer({ map });\n  let particles = new ParticleCollection();\n\n  let gameLoop = (currentTime) => {\n    window.requestAnimationFrame(gameLoop);\n    if (currentTime - lastTime) {\n      tick();\n      drawer.clearBackground();\n      drawer.clearMiniMap();\n      drawObjects().map((object) => object.draw(drawer));\n      lastTime = currentTime - (delta % interval);\n    }\n  };\n\n  let tick = () => {\n    const { camera } = drawer;\n    level.tick({ cpuPlayer, humanPlayer });\n    camera.tick({ keyboard, mouse });\n    mouse.tick({ camera });\n    cpuPlayer.tick({\n      map,\n      mines,\n      particles,\n      sound,\n      targets: humanPlayer.entities(),\n    });\n    humanPlayer.tick({\n      camera,\n      cpuPlayer,\n      drawer,\n      map,\n      mines,\n      mouse,\n      particles,\n      sound,\n      targets: cpuPlayer.entities(),\n    });\n    mines.tick();\n    hud.tick({ camera, drawer, map, mouse, player: humanPlayer, sound });\n    particles.tick({ map });\n    fogOfWar.tick({ humanPlayer, cpuPlayer, mines, map });\n  };\n\n  let drawObjects = () => [\n    background,\n    map,\n    particles,\n    mines,\n    cpuPlayer,\n    humanPlayer,\n    mouse,\n    fogOfWar,\n    hud,\n    miniMap,\n    level,\n  ];\n\n  gameLoop();\n};\n","export default {\n  blood: {\n    draw: function (drawer) {\n      drawer.rect({\n        fillColor: this.color,\n        rect: [this.x, this.y, 5, 5],\n      });\n    },\n  },\n  chunk: {\n    draw: function (drawer) {\n      const glistenColor = \"#FF77A8\";\n      drawer.rect({\n        fillColor: this.color,\n        rect: [this.x, this.y - 10, 10, 15],\n      });\n\n      [\n        [1, 2],\n        [2, 3],\n      ].forEach(([x, y]) => {\n        drawer.rect({\n          fillColor: this.color,\n          rect: [this.x + (x - 2) * 5, this.y + (y - 2) * 5, 5, 5],\n        });\n      });\n\n      [\n        [2, 0],\n        [1, 1],\n        [0, 2],\n        [1, 3],\n      ].forEach(([x, y]) => {\n        drawer.rect({\n          fillColor: glistenColor,\n          rect: [this.x + (x - 2) * 5, this.y + (y - 2) * 5, 5, 5],\n        });\n      });\n    },\n  },\n  bit: {\n    draw: function (drawer) {\n      drawer.rect({\n        fillColor: this.color,\n        rect: [this.x, this.y, 20, 20],\n      });\n    },\n  },\n};\n","const makeColors = ([skin, eyes, body]) => ({ skin, eyes, body });\n\n// prettier-ignore\nexport const shadeColors = (color) => makeColors([\"#999\", color, color]);\n// prettier-ignore\nexport const goblinColors = (color) => makeColors([\"#50c878\", color, color]);\n// prettier-ignore\nexport const bruteColors = (color) => makeColors([\"#c80\", color, color]);\n// prettier-ignore\nexport const speederColors = (color) => makeColors([\"#cff\", color, color]);\n\nconst defaultUnit = {\n  name: \"goblin\",\n  health: 50,\n  damage: 10,\n  size: 8 * 5,\n  cost: 100,\n  buildTime: 5 * 30,\n  bloodColor: \"#A00\",\n  aggro: true,\n  colors: goblinColors,\n  speed: 5,\n  bodyless: false,\n  horns: true,\n  antenna: false,\n  bouncy: true,\n  attackSound: \"gun\",\n  canMine: false,\n  flying: false,\n  builder: false,\n\n  range: 300,\n  cooldownTotalTime: 90,\n  firingTotalTime: 60,\n};\n\n// prettier-ignore\nexport default {\n  \"shade\": {\n    ...defaultUnit,\n    name: \"shade\",\n    damage: 1,\n    aggro: false,\n    colors: shadeColors,\n    speed: 3,\n    bodyless: true,\n    bouncy: false,\n    attackSound: \"minigun\",\n    canMine: true,\n    flying: true,\n    builder: true,\n\n    range: 50,\n    cooldownTotalTime: 10,\n    firingTotalTime: 10,\n  },\n  \"goblin\": {\n    ...defaultUnit,\n  },\n  \"brute\": {\n    ...defaultUnit,\n    name: \"brute\",\n    health: 100,\n    damage: 15,\n    size: 8 * 10,\n    cost: 200,\n    horns: false,\n    brute: true,\n    buildTime: 10 * 30,\n    colors: bruteColors,\n    speed: 3,\n\n    range: 100,\n  },\n  \"speeder\": {\n    ...defaultUnit,\n    name: \"speeder\",\n    health: 150,\n    damage: 5,\n    cost: 200,\n    horns: false,\n    antenna: true,\n    buildTime: 10 * 30,\n    colors: speederColors,\n    speed: 8,\n\n    range: 50,\n  }\n};\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/LA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvhBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnfA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtSA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5HA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACznBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}