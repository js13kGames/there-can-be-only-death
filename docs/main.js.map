{"version":3,"file":"main.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/Background.js","webpack:///./src/Building.js","webpack:///./src/Camera.js","webpack:///./src/Drawer.js","webpack:///./src/Keyboard.js","webpack:///./src/Map.js","webpack:///./src/Mouse.js","webpack:///./src/Player.js","webpack:///./src/Unit.js","webpack:///./src/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export default class Background {\n  draw(drawer) {\n    drawer.draw(() => {\n      drawer.drawBackground();\n    });\n  }\n}\n","import Map from \"./Map\";\n\nclass Building {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.sizeX = Map.tileSize * 3;\n    this.sizeY = Map.tileSize * 2;\n    this.lifespan = 0;\n    this.selected = false;\n  }\n\n  tick() {}\n\n  draw(drawer) {\n    if (this.selected) {\n      drawer.ellipse({\n        ellipse: [\n          this.x + this.sizeX / 2,\n          this.y + this.sizeY,\n          (this.sizeX + 40) / 2,\n          this.sizeY / 4,\n          0,\n          0,\n          2 * Math.PI,\n        ],\n        strokeColor: \"#39C\",\n        strokeWidth: 5,\n      });\n    }\n\n    drawer.rect({\n      fillColor: \"#A33\",\n      rect: [this.x, this.y, this.sizeX, this.sizeY],\n    });\n\n    drawer.miniMap({\n      x: this.x,\n      y: this.y,\n      color: \"#C33\",\n      sizeX: Math.ceil(this.sizeX / 20),\n      sizeY: Math.ceil(this.sizeY / 20),\n    });\n  }\n}\n\nexport default Building;\n","import Map from \"./Map\";\n\nclass Camera {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.position_x = 0;\n    this.position_y = 0;\n    this.shakeRemaining = 0;\n    this.shakeForce = 0;\n  }\n\n  adjustX(x) {\n    return x - this.x;\n  }\n\n  adjustY(y) {\n    return y - this.y;\n  }\n\n  clampX(maxX) {\n    this.position_x = Math.min(Math.max(0, this.position_x), maxX);\n  }\n\n  clampY(maxY) {\n    this.position_y = Math.min(Math.max(0, this.position_y), maxY);\n  }\n\n  shake(force, duration) {\n    if (force >= this.shakeForce || this.shakeRemaining === 0) {\n      this.shakeRemaining = duration;\n      this.shakeForce = force;\n    }\n  }\n\n  applyShake() {\n    this.shakeRemaining = Math.max(0, this.shakeRemaining - 1);\n    if (!this.shakeRemaining) return;\n    const shakeX = Math.random() * this.shakeForce * 2 - this.shakeForce;\n    const shakeY = Math.random() * this.shakeForce * 2 - this.shakeForce;\n    this.x += shakeX;\n    this.y += shakeY;\n  }\n\n  tick({ keyboard }) {\n    const speed = 10;\n    if (keyboard.isDown(keyboard.UP)) this.position_y -= speed;\n    if (keyboard.isDown(keyboard.DOWN)) this.position_y += speed;\n    if (keyboard.isDown(keyboard.LEFT)) this.position_x -= speed;\n    if (keyboard.isDown(keyboard.RIGHT)) this.position_x += speed;\n    this.clampX(Map.size - this.width);\n    this.clampY(Map.size * (Map.tileSizeY / Map.tileSize) - this.height);\n\n    this.x = this.position_x;\n    this.y = this.position_y;\n    this.applyShake();\n  }\n}\n\nexport default Camera;\n","import Camera from \"./Camera\";\nimport Map from \"./Map\";\n\nlet cx = null;\n\nexport default class Drawer {\n  constructor() {\n    let canvas = document.querySelector(\"canvas\");\n    this.canvas = canvas;\n    cx = this.canvas.getContext(\"2d\");\n    this.camera = new Camera();\n\n    let container = document.querySelector(\"body\");\n    let resize = () => {\n      this.camera.height = window.innerHeight;\n      this.camera.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      canvas.width = window.innerWidth;\n      this.height = canvas.height;\n      this.width = canvas.width;\n    };\n    resize();\n    container.onresize = resize;\n  }\n\n  draw(d) {\n    cx.save();\n    d();\n    cx.restore();\n  }\n\n  clearBackground() {\n    cx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  drawBackground() {\n    this.draw(() => {\n      cx.fillStyle = \"#242\";\n      cx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    });\n  }\n\n  rect({\n    rect,\n    fillColor,\n    strokeColor,\n    shadowBlur = 0,\n    shadowColor = \"none\",\n    opacity,\n    lineWidth = 1,\n    adjusted = true,\n    rotation,\n    size,\n    crisp = true,\n  }) {\n    if (crisp) {\n      rect[0] = Math.floor(rect[0]);\n      rect[1] = Math.floor(rect[1]);\n    }\n    if (adjusted) {\n      rect[0] = this.camera.adjustX(rect[0], this.canvas.width);\n      rect[1] = this.camera.adjustY(rect[1], this.canvas.height);\n    }\n    if (rotation) {\n      cx.translate(rect[0] + size / 2, rect[1] + size / 2);\n      cx.rotate(rotation);\n      cx.translate(-1 * rect[0] - size / 2, -1 * rect[1] - size / 2);\n    }\n    cx.shadowBlur = shadowBlur;\n    cx.shadowColor = shadowColor;\n    if (opacity) {\n      cx.globalAlpha = opacity;\n    }\n    if (fillColor) {\n      cx.fillStyle = fillColor;\n      cx.fillRect(...[rect[0], rect[1], ...rect.slice(2)]);\n    }\n    if (strokeColor) {\n      cx.strokeStyle = strokeColor;\n      cx.lineWidth = lineWidth;\n      cx.strokeRect(...[rect[0], rect[1], ...rect.slice(2)]);\n    }\n    cx.shadowBlur = 0;\n    cx.globalAlpha = 1;\n  }\n\n  ellipse({\n    ellipse,\n    adjusted = true,\n    fillColor,\n    strokeColor,\n    strokeWidth = 1,\n    shadowBlur,\n    shadowColor,\n  }) {\n    if (adjusted) {\n      ellipse[0] = this.camera.adjustX(ellipse[0], this.canvas.width);\n      ellipse[1] = this.camera.adjustY(ellipse[1], this.canvas.height);\n    }\n    cx.beginPath();\n    cx.ellipse(...ellipse);\n    cx.shadowBlur = shadowBlur;\n    cx.shadowColor = shadowColor;\n    if (fillColor) {\n      cx.fillStyle = fillColor;\n      cx.fill();\n    }\n    if (strokeColor) {\n      cx.strokeStyle = strokeColor;\n      cx.lineWidth = strokeWidth;\n      cx.stroke();\n    }\n    cx.shadowBlur = 0;\n  }\n\n  text({ text, x, y, fillColor = \"#fff\", size = 1 }) {\n    cx.fillStyle = fillColor;\n\n    let currX = 0;\n\n    text\n      .toUpperCase()\n      .split(\"\")\n      .map((c) => {\n        if (!letters[c]) console.log(c);\n        return letters[c];\n      })\n      .forEach((letter) => {\n        let currY = 0;\n        let addX = 0;\n        letter.forEach((row) => {\n          row.forEach((bit, i) => {\n            bit && cx.fillRect(currX + i * size + x, currY + y, size, size);\n          });\n          addX = Math.max(addX, row.length * size);\n          currY += size;\n        });\n        currX += size + addX;\n      });\n  }\n\n  lines({ lines, shadowBlur = 0, shadowColor, fillColor, strokeColor }) {\n    cx.beginPath();\n    cx.moveTo(lines[0][0], lines[0][1]);\n    lines.slice(1).map((line) => cx.lineTo(line[0], line[1]));\n    cx.closePath();\n    cx.shadowBlur = shadowBlur;\n    cx.shadowColor = shadowColor;\n    if (strokeColor) {\n      cx.strokeStyle = strokeColor;\n      cx.stroke();\n    }\n    if (fillColor) {\n      cx.fillStyle = fillColor;\n      cx.fill();\n    }\n  }\n\n  emoji({ emoji, x, y, flipped, adjusted = true }) {\n    this.draw(() => {\n      if (adjusted) {\n        x = this.camera.adjustX(x, this.canvas.width);\n        y = this.camera.adjustY(y, this.canvas.height);\n      }\n      if (flipped) {\n        // cx.scale(-1, 1);\n        // cx.translate(canvasWidth.width / 2, canvasHeight.height / 2);\n      }\n\n      cx.font = \"6px serif\";\n      cx.fillText(emoji, x, y + 2);\n    });\n  }\n\n  miniMap({ x, y, size, sizeX, sizeY, color }) {\n    this.draw(() => {\n      this.rect({\n        adjusted: false,\n        fillColor: color,\n        rect: [\n          this.canvas.width - 200 + (x / Map.size) * 200,\n          this.canvas.height - 200 + (y / Map.size) * 200,\n          sizeX || size,\n          sizeY || size,\n        ],\n      });\n    });\n  }\n\n  hitbox({ x, y, size }) {\n    this.rect({\n      rect: [x - size / 2, y - size / 2, size, size],\n      color: \"#f00\",\n    });\n  }\n}\n\nconst letters = {};\nletters[\"A\"] = [\n  [, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n  [1, , 1],\n];\nletters[\"B\"] = [\n  [1, 1],\n  [1, , 1],\n  [1, 1, 1],\n  [1, , 1],\n  [1, 1],\n];\nletters[\"C\"] = [[1, 1, 1], [1], [1], [1], [1, 1, 1]];\nletters[\"D\"] = [\n  [1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1],\n];\nletters[\"E\"] = [[1, 1, 1], [1], [1, 1, 1], [1], [1, 1, 1]];\nletters[\"F\"] = [[1, 1, 1], [1], [1, 1], [1], [1]];\nletters[\"G\"] = [[, 1, 1], [1], [1, , 1, 1], [1, , , 1], [, 1, 1]];\nletters[\"H\"] = [\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n  [1, , 1],\n  [1, , 1],\n];\nletters[\"I\"] = [\n  [1, 1, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n  [1, 1, 1],\n];\nletters[\"J\"] = [\n  [1, 1, 1],\n  [, , 1],\n  [, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"K\"] = [\n  [1, , , 1],\n  [1, , 1],\n  [1, 1],\n  [1, , 1],\n  [1, , , 1],\n];\nletters[\"L\"] = [[1], [1], [1], [1], [1, 1, 1]];\nletters[\"M\"] = [\n  [1, 1, 1, 1, 1],\n  [1, , 1, , 1],\n  [1, , 1, , 1],\n  [1, , , , 1],\n  [1, , , , 1],\n];\nletters[\"N\"] = [\n  [1, , , 1],\n  [1, 1, , 1],\n  [1, , 1, 1],\n  [1, , , 1],\n  [1, , , 1],\n];\nletters[\"O\"] = [\n  [1, 1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"P\"] = [[1, 1, 1], [1, , 1], [1, 1, 1], [1], [1]];\nletters[\"Q\"] = [\n  [0, 1, 1],\n  [1, , , 1],\n  [1, , , 1],\n  [1, , 1, 1],\n  [1, 1, 1, 1],\n];\nletters[\"R\"] = [\n  [1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1],\n  [1, , 1],\n];\nletters[\"S\"] = [[1, 1, 1], [1], [1, 1, 1], [, , 1], [1, 1, 1]];\nletters[\"T\"] = [\n  [1, 1, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n];\nletters[\"U\"] = [\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"V\"] = [\n  [1, , , , 1],\n  [1, , , , 1],\n  [, 1, , 1],\n  [, 1, , 1],\n  [, , 1],\n];\nletters[\"W\"] = [\n  [1, , , , 1],\n  [1, , , , 1],\n  [1, , , , 1],\n  [1, , 1, , 1],\n  [1, 1, 1, 1, 1],\n];\nletters[\"X\"] = [\n  [1, , , , 1],\n  [, 1, , 1],\n  [, , 1],\n  [, 1, , 1],\n  [1, , , , 1],\n];\nletters[\"Y\"] = [\n  [1, , 1],\n  [1, , 1],\n  [, 1],\n  [, 1],\n  [, 1],\n];\nletters[\"Z\"] = [\n  [1, 1, 1, 1, 1],\n  [, , , 1],\n  [, , 1],\n  [, 1],\n  [1, 1, 1, 1, 1],\n];\nletters[\" \"] = [\n  [, ,],\n  [, ,],\n  [, ,],\n  [, ,],\n  [, ,],\n];\nletters[\"0\"] = [\n  [1, 1, 1],\n  [1, , 1],\n  [1, , 1],\n  [1, , 1],\n  [1, 1, 1],\n];\nletters[\"1\"] = [\n  [, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n  [, 1],\n];\nletters[\"2\"] = [\n  [1, 1, 1],\n  [0, 0, 1],\n  [1, 1, 1],\n  [1, 0, 0],\n  [1, 1, 1],\n];\nletters[\"3\"] = [\n  [1, 1, 1],\n  [0, 0, 1],\n  [1, 1, 1],\n  [0, 0, 1],\n  [1, 1, 1],\n];\nletters[\"4\"] = [\n  [1, 0, 1],\n  [1, 0, 1],\n  [1, 1, 1],\n  [0, 0, 1],\n  [0, 0, 1],\n];\nletters[\"5\"] = [\n  [1, 1, 1],\n  [1, 0, 0],\n  [1, 1, 1],\n  [0, 0, 1],\n  [1, 1, 1],\n];\nletters[\"6\"] = [\n  [1, 1, 1],\n  [1, 0, 0],\n  [1, 1, 1],\n  [1, 0, 1],\n  [1, 1, 1],\n];\nletters[\"7\"] = [\n  [1, 1, 1],\n  [0, 0, 1],\n  [0, 0, 1],\n  [0, 0, 1],\n  [0, 0, 1],\n];\nletters[\"8\"] = [\n  [1, 1, 1],\n  [1, 0, 1],\n  [1, 1, 1],\n  [1, 0, 1],\n  [1, 1, 1],\n];\nletters[\"9\"] = [\n  [1, 1, 1],\n  [1, 0, 1],\n  [1, 1, 1],\n  [0, 0, 1],\n  [1, 1, 1],\n];\n","class Keyboard {\n  constructor() {\n    document.addEventListener(\"keyup\", (event) => this.onKeyup(event));\n    document.addEventListener(\"keydown\", (event) => this.onKeydown(event));\n\n    this._pressed = {};\n\n    this.SPACE = { keyboard: [32], controller: [0, 1, 5, 7] };\n    this.LEFT = { keyboard: [37, 65], controller: [14], dir: \"l\" };\n    this.UP = { keyboard: [38, 87, 16, 17], controller: [12, 2, 3] };\n    this.RIGHT = { keyboard: [39, 68], controller: [15], dir: \"r\" };\n    this.DOWN = { keyboard: [40, 83], controller: [13] };\n  }\n\n  isDownControllerStick(dir) {\n    if (!navigator.getGamepads()[0]) return false;\n    const axes = navigator.getGamepads()[0].axes;\n\n    return {\n      l: axes[0] < 0,\n      r: axes[0] > 0,\n    }[dir];\n  }\n\n  isDownController(keyCode) {\n    if (!navigator.getGamepads()[0]) return false;\n\n    return navigator\n      .getGamepads()[0]\n      .buttons.reduce((acc, b, i) => (b.pressed ? acc.concat([i]) : acc), [])\n      .some((b) => keyCode.includes(b));\n  }\n\n  isDownKeyboard(keyCode) {\n    return keyCode.some((key) => this._pressed[key]);\n  }\n\n  isDown(keyCode) {\n    return (\n      this.isDownControllerStick(keyCode.dir) ||\n      this.isDownKeyboard(keyCode.keyboard) ||\n      this.isDownController(keyCode.controller) ||\n      false\n    );\n  }\n\n  onKeydown(event) {\n    this._pressed[event.keyCode] = true;\n  }\n\n  onKeyup(event) {\n    delete this._pressed[event.keyCode];\n  }\n}\n\nexport default Keyboard;\n","class Map {\n  constructor() {\n    this.map = [];\n    for (let y = 0; y < Map.size / Map.tileSize; y++) {\n      const row = [];\n      for (let x = 0; x < Map.size / Map.tileSize; x++) {\n        row.push((x + y) % 2);\n      }\n      this.map.push(row);\n    }\n  }\n\n  tick() {}\n\n  draw(drawer) {\n    this.map.forEach((row, y) => {\n      row.forEach((cell, x) => {\n        const color = cell ? \"#bbb\" : \"#ddd\";\n        drawer.rect({\n          fillColor: color,\n          rect: [\n            x * Map.tileSizeX,\n            y * Map.tileSizeY,\n            Map.tileSizeX,\n            Map.tileSizeY,\n          ],\n        });\n      });\n    });\n\n    // minimap\n    const minimapSize = 200;\n    drawer.rect({\n      adjusted: false,\n      fillColor: \"#eee\",\n      rect: [\n        drawer.width - minimapSize,\n        drawer.height - minimapSize,\n        minimapSize,\n        minimapSize,\n      ],\n    });\n\n    const x =\n      drawer.width -\n      minimapSize +\n      (drawer.camera.position_x / Map.size) * minimapSize;\n    const y =\n      drawer.height -\n      minimapSize +\n      (drawer.camera.position_y / ((Map.tileSizeY / Map.tileSize) * Map.size)) *\n        minimapSize;\n    drawer.rect({\n      adjusted: false,\n      strokeColor: \"#333\",\n      rect: [\n        x,\n        y,\n        (drawer.width / Map.size) * minimapSize,\n        (drawer.height / ((Map.tileSizeY / Map.tileSize) * Map.size)) *\n          minimapSize,\n      ],\n    });\n  }\n}\n\nMap.mapAdjust = (x, y) => [\n  (x * Map.tileSizeX) / Map.tileSize,\n  (y * Map.tileSizeY) / Map.tileSize,\n];\n\nMap.size = 4000;\nMap.tileSize = 80;\nMap.tileSizeX = 80;\nMap.tileSizeY = 80;\n\nexport default Map;\n","const DRAG_THRESHOLD = 20;\n\nclass Mouse {\n  constructor() {\n    let canvas = document.querySelector(\"canvas\");\n    this.canvas = canvas;\n    this.canvas.addEventListener(\"click\", (event) => this.click(event));\n    this.canvas.addEventListener(\"mousedown\", (event) => this.mousedown(event));\n    this.canvas.addEventListener(\"mouseup\", (event) => this.mouseup(event));\n    this.canvas.addEventListener(\"mousemove\", (event) => this.mousemove(event));\n    this.canvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n      this.rightClick(event);\n    });\n    this.clickCoords = [null, null];\n    this.dragging = false;\n    this.prevDragging = false;\n    this.releaseDrag = null;\n    this.startDragLocation = [null, null];\n  }\n\n  tick({ camera }) {\n    this.camera = camera;\n\n    this.releaseDrag = null;\n    if (this.prevDragging && !this.dragging) {\n      if (\n        Math.abs(this.startDragLocation[0] - this.mouseLocation[0]) >\n          DRAG_THRESHOLD ||\n        Math.abs(this.startDragLocation[1] - this.mouseLocation[1]) >\n          DRAG_THRESHOLD\n      ) {\n        this.releaseDrag = this.startDragLocation.concat(this.mouseLocation);\n        this.startDragLocation = [null, null];\n      }\n    }\n    this.prevDragging = this.dragging;\n\n    const clickTarget = this.clickCoords;\n    const rightClickTarget = this.rightClickCoords;\n    const releaseDrag = this.releaseDrag;\n    this.clickCoords = this.rightClickCoords = [null, null];\n    return { clickTarget, rightClickTarget, releaseDrag };\n  }\n\n  click({ clientX, clientY }) {\n    this.clickCoords = [clientX + this.camera.x, clientY + this.camera.y];\n  }\n\n  mousedown({ clientX, clientY }) {\n    this.startDragLocation = [clientX + this.camera.x, clientY + this.camera.y];\n    this.dragging = true;\n  }\n\n  mouseup() {\n    this.dragging = false;\n  }\n\n  mousemove({ clientX, clientY }) {\n    this.mouseLocation = [clientX + this.camera.x, clientY + this.camera.y];\n  }\n\n  rightClick({ clientX, clientY }) {\n    this.rightClickCoords = [clientX + this.camera.x, clientY + this.camera.y];\n  }\n\n  draw(drawer) {\n    if (this.dragging) {\n      drawer.rect({\n        rect: [\n          this.startDragLocation[0],\n          this.startDragLocation[1],\n          this.mouseLocation[0] - this.startDragLocation[0],\n          this.mouseLocation[1] - this.startDragLocation[1],\n        ],\n        strokeColor: \"#369\",\n      });\n    }\n  }\n}\n\nexport default Mouse;\n","import Building from \"./Building\";\nimport Unit from \"./Unit\";\n\nconst boxCollision = (rect1, rect2) =>\n  rect1.x < rect2.x + rect2.w &&\n  rect1.x + rect1.w > rect2.x &&\n  rect1.y < rect2.y + rect2.h &&\n  rect1.h + rect1.y > rect2.y;\n\nclass Player {\n  constructor() {\n    this.units = [\n      new Unit(100, 200),\n      new Unit(300, 200),\n      new Unit(500, 200),\n      new Unit(700, 200),\n      new Unit(100, 400),\n      new Unit(300, 400),\n      new Unit(500, 400),\n      new Unit(700, 400),\n    ];\n\n    this.buildings = [new Building(400, 80 * 8)];\n    this.selected = null;\n  }\n\n  dragSelect(mouseEvents, entities) {\n    const collisions = entities.filter((entity) => {\n      let { x, y, size, sizeX, sizeY } = entity;\n      let [mx, my, endx, endy] = mouseEvents.releaseDrag;\n      return boxCollision(\n        { x, y, w: sizeX || size, h: sizeY || size },\n        { x: mx, y: my, w: endx - mx, h: endy - my }\n      );\n    });\n    if (collisions.length) {\n      entities.forEach((entity) => (entity.selected = false));\n      collisions.forEach((entity) => (entity.selected = true));\n    }\n  }\n\n  clickSelect(mouseEvents, entities) {\n    let [mouseX, mouseY] = mouseEvents.clickTarget;\n    if (mouseX || mouseY) {\n      entities.forEach((entity) => {\n        let { x, y, size, sizeX, sizeY } = entity;\n        if (\n          mouseX >= x &&\n          mouseX < x + (size || sizeX) &&\n          mouseY >= y &&\n          mouseY < y + (size || sizeY)\n        ) {\n          entities.forEach((entity) => (entity.selected = false));\n          this.selected = entity;\n          entity.selected = true;\n        }\n      });\n    }\n  }\n\n  select(mouseEvents) {\n    const entities = [this.units, this.buildings].flat();\n    if (mouseEvents.releaseDrag) {\n      this.dragSelect(mouseEvents, entities);\n    } else {\n      this.clickSelect(mouseEvents, entities);\n    }\n  }\n\n  tick({ mouseEvents }) {\n    this.select(mouseEvents);\n    this.units.forEach((u) => u.tick({ mouseEvents }));\n    this.buildings.forEach((b) => b.tick());\n  }\n\n  draw(drawer) {\n    this.units.forEach((u) => u.draw(drawer));\n    this.buildings.forEach((b) => b.draw(drawer));\n  }\n}\n\nexport default Player;\n","const IDLE = \"idle\";\nconst WALKING = \"walking\";\n\nclass Unit {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.dx = 0;\n    this.dy = 0;\n    this.size = 40;\n    this.lifespan = 0;\n    this.selected = false;\n    this.speed = 5;\n    this.path = [];\n  }\n\n  setPath(target) {\n    this.path = [target];\n  }\n\n  calculateSpeed() {\n    let [targetX, targetY] = this.path[0];\n\n    // normalize vector\n    let u = Math.sqrt(\n      Math.pow(this.x - targetX, 2) + Math.pow(this.y - targetY, 2)\n    );\n\n    // if close enough to destination, remove waypoint\n    if (u > this.speed) {\n      this.dx = this.speed * ((targetX - this.x) / Math.abs(u));\n      this.dy = this.speed * ((targetY - this.y) / Math.abs(u));\n    } else {\n      this.path.pop();\n    }\n  }\n\n  move() {\n    if (this.path.length) {\n      this.calculateSpeed();\n      this.state = WALKING;\n    } else {\n      this.dx = 0;\n      this.dy = 0;\n      this.state = IDLE;\n    }\n    this.x += this.dx;\n    this.y += this.dy;\n  }\n\n  tick({ mouseEvents }) {\n    this.lifespan += 1;\n\n    if (\n      this.selected &&\n      (mouseEvents.rightClickTarget[0] || mouseEvents.rightClickTarget[1])\n    ) {\n      this.setPath(mouseEvents.rightClickTarget);\n    }\n\n    this.move();\n  }\n\n  draw(drawer) {\n    if (this.selected) {\n      drawer.ellipse({\n        ellipse: [\n          this.x + this.size / 2,\n          this.y + this.size,\n          (this.size + 20) / 2,\n          this.size / 3,\n          0,\n          0,\n          2 * Math.PI,\n        ],\n        strokeColor: \"#39C\",\n        strokeWidth: 5,\n      });\n    }\n\n    drawer.rect({\n      fillColor: \"#A33\",\n      rect: [this.x, this.y, this.size, this.size],\n    });\n\n    drawer.miniMap({\n      x: this.x,\n      y: this.y,\n      color: \"#C33\",\n      size: Math.ceil(this.size / 20),\n    });\n  }\n}\n\nexport default Unit;\n","import Background from \"./Background\";\nimport Drawer from \"./Drawer\";\nimport Keyboard from \"./Keyboard\";\nimport Map from \"./Map\";\nimport Mouse from \"./Mouse\";\nimport Player from \"./Player\";\n\nlet fps = 60,\n  interval = 1000 / fps,\n  lastTime = 0,\n  delta = 0;\n\n/*\nimport Sound from \"./Sound\";\nimport CollisionDetector from \"./CollisionDetector\";\n\nimport Level from \"./Level\";\nimport Map from \"./Map\";\nimport HUD from \"./HUD\";\nimport EnemyCollection from \"./EnemyCollection\";\nimport ProjectileCollection from \"./ProjectileCollection\";\nimport BloodCollection from \"./BloodCollection\";\nimport PackageCollection from \"./PackageCollection\";\n*/\n\nwindow.onload = () => {\n  let drawer = new Drawer();\n\n  let background = new Background({\n    cw: drawer.canvas.width,\n    ch: drawer.canvas.height,\n  });\n  let keyboard = new Keyboard();\n  let mouse = new Mouse();\n\n  let map = new Map();\n  let player = new Player();\n\n  /*\n  let sound = new Sound();\n  let collisionDetector = new CollisionDetector();\n\n\n  let level = new Level();\n  let hud = new HUD();\n  let enemies = new EnemyCollection();\n  let projectiles = new ProjectileCollection();\n  let spurts = new BloodCollection();\n  let chunks = { chunks: [] };\n  let packages = new PackageCollection();\n\n  level.initializeLevel(1, {\n    player,\n    enemies,\n    chunks,\n    spurts,\n    packages,\n    map,\n  });\n  */\n\n  let gameLoop = (currentTime) => {\n    window.requestAnimationFrame(gameLoop);\n    if (currentTime - lastTime) {\n      tick();\n      drawer.clearBackground();\n      drawObjects().map((object) => object.draw(drawer));\n      lastTime = currentTime - (delta % interval);\n    }\n  };\n\n  let tick = () => {\n    const { camera } = drawer;\n    camera.tick({ keyboard });\n    const mouseEvents = mouse.tick({ camera });\n    player.tick({ mouseEvents });\n\n    /*\n    level.tick({\n      player,\n      enemies,\n      chunks,\n      spurts,\n      packages,\n      sound,\n      map,\n      background,\n    });\n    player.tick({ camera, keyboard, map, projectiles, sound, chunks, spurts });\n    enemies.tick({\n      camera,\n      map,\n      projectiles,\n      spurts,\n      chunks,\n      player,\n      sound,\n      level,\n    });\n    camera.tick({ player, map });\n    projectiles.tick();\n    spurts.tick();\n\n    if (chunks.chunks.length > 1000) {\n      chunks.chunks = chunks.chunks.slice(chunks.chunks.length - 1000);\n    }\n    chunks.chunks.forEach((chunk) => chunk.tick());\n\n    hud.tick(player, enemies, level.level.enemyColor);\n    packages.tick(map, level.level.level);\n    */\n  };\n\n  let drawObjects = () => [background, map, player, mouse];\n\n  gameLoop();\n};\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9ZA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5EA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}